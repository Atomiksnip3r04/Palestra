rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // User profiles: Users can read/write only their own data
    // Other authenticated users can read basic profile info (for friends feature)
    match /users/{userId} {
      // Anyone authenticated can read user profiles (for search/friends)
      allow read: if request.auth != null;
      // Only the user can write their own profile
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Private subcollection (health tokens, etc.)
      match /private/{document=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // Health data subcollection
      match /health/{healthId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // Config: Restricted read for authenticated users only, Admin write only
    // SECURITY FIX: Prevent anonymous access to global config
    match /config/global {
      allow read: if request.auth != null;
      allow write: if false; // Admin only via Console
    }
    
    // Terra API Config: Read for authenticated users, Admin write only
    match /config/terra {
      allow read: if request.auth != null;
      allow write: if false; // Admin only via Console
    }
    
    // ImgBB Config: Authenticated users only (prevents API key exposure)
    match /config/imgbb {
      allow read: if request.auth != null;
      allow write: if false; // Admin only via Console
    }
    
    // Health Auto Export Config: Authenticated users only
    match /config/healthAutoExport {
      allow read: if request.auth != null;
      allow write: if false; // Admin only via Console
    }
    
    // Shared Workouts: 
    // SECURITY FIX: Validate creator and add write restrictions
    // - Create: Only authenticated users, must set themselves as creator
    // - Update/Delete: Only the original creator
    // - Read: Publicly readable (so anyone with the link can import it)
    match /shared_workouts/{shareId} {
      allow create: if request.auth != null 
                    && request.resource.data.creatorId == request.auth.uid
                    && request.resource.data.name is string
                    && request.resource.data.name.size() > 0
                    && request.resource.data.name.size() <= 100;
      allow update, delete: if request.auth != null 
                            && resource.data.creatorId == request.auth.uid;
      allow read: if true; 
    }
    
    // Shared Workout Logs (Diary entries):
    // SECURITY FIX: Same restrictions as shared_workouts
    // - Create: Only authenticated users, must set themselves as creator
    // - Update/Delete: Only the original creator
    // - Read: Publicly readable (so anyone with the link can import it)
    match /shared_logs/{shareId} {
      allow create: if request.auth != null 
                    && request.resource.data.creatorId == request.auth.uid;
      allow update, delete: if request.auth != null 
                            && resource.data.creatorId == request.auth.uid;
      allow read: if true; 
    }
    
    // ============================================
    // GYMBRO SOCIAL LAYER - Friendships
    // ============================================
    // Single source of truth for each friendship pair
    // friendshipId = sorted(uidA, uidB).join('_') for deterministic ID
    // Status: pending_from_a, pending_from_b, accepted, blocked
    match /friendships/{friendshipId} {
      // Only the two participants can read their friendship
      allow read: if request.auth != null 
                  && request.auth.uid in resource.data.participants;
      
      // Create: authenticated user must be in participants and set as createdBy
      allow create: if request.auth != null 
                    && request.auth.uid in request.resource.data.participants
                    && request.resource.data.createdBy == request.auth.uid
                    && request.resource.data.participants.size() == 2;
      
      // Update: only participants can update (accept/reject/block)
      allow update: if request.auth != null 
                    && request.auth.uid in resource.data.participants;
      
      // Delete: only participants can delete (unfriend)
      allow delete: if request.auth != null 
                    && request.auth.uid in resource.data.participants;
    }
    
    // ============================================
    // GYMBRO SOCIAL LAYER - Gymbro Rooms
    // ============================================
    // Virtual rooms for shared real-time workouts
    // Status: lobby, active, finished, archived
    match /gymbro_rooms/{roomId} {
      // Helper function: check if user is a member of the room
      function isMember() {
        return exists(/databases/$(database)/documents/gymbro_rooms/$(roomId)/members/$(request.auth.uid));
      }
      
      // Helper function: check if user is the host
      function isHost() {
        return resource.data.hostId == request.auth.uid;
      }
      
      // Read: only members can see room details
      allow read: if request.auth != null && isMember();
      
      // Create: authenticated user must set themselves as host
      allow create: if request.auth != null 
                    && request.resource.data.hostId == request.auth.uid
                    && request.resource.data.status == 'lobby';
      
      // Update: only host can update room settings (start/end workout, etc.)
      allow update: if request.auth != null && isHost();
      
      // Delete: only host can delete (archive) the room
      allow delete: if request.auth != null && isHost();
      
      // --- Members Subcollection ---
      // Each member document ID = user's UID
      match /members/{memberId} {
        // Read: all room members can see who's in the room
        allow read: if request.auth != null 
                    && exists(/databases/$(database)/documents/gymbro_rooms/$(roomId)/members/$(request.auth.uid));
        
        // Create: user can add themselves to the room (join)
        // OR host can add members (invite accepted)
        allow create: if request.auth != null 
                      && (request.auth.uid == memberId
                          || get(/databases/$(database)/documents/gymbro_rooms/$(roomId)).data.hostId == request.auth.uid);
        
        // Update: only the member themselves can update their status (ready, etc.)
        allow update: if request.auth != null && request.auth.uid == memberId;
        
        // Delete: member can remove themselves (leave)
        // OR host can remove members (kick)
        allow delete: if request.auth != null 
                      && (request.auth.uid == memberId
                          || get(/databases/$(database)/documents/gymbro_rooms/$(roomId)).data.hostId == request.auth.uid);
      }
      
      // --- Active Metrics Subcollection ---
      // Real-time workout metrics per user (high-frequency writes)
      // CRITICAL: Each user writes ONLY to their own document to avoid contention
      match /activeMetrics/{metricUserId} {
        // Read: all room members can see everyone's metrics (leaderboard)
        allow read: if request.auth != null 
                    && exists(/databases/$(database)/documents/gymbro_rooms/$(roomId)/members/$(request.auth.uid));
        
        // Write: users can ONLY write to their own metrics document
        allow write: if request.auth != null && request.auth.uid == metricUserId;
      }
      
      // --- Workout Log Subcollection ---
      // Append-only log of all exercises during the session (for analytics/replay)
      match /workoutLog/{logId} {
        // Read: all room members can read the log
        allow read: if request.auth != null 
                    && exists(/databases/$(database)/documents/gymbro_rooms/$(roomId)/members/$(request.auth.uid));
        
        // Create: authenticated users can append to log (must set their UID)
        allow create: if request.auth != null 
                      && request.resource.data.uid == request.auth.uid
                      && exists(/databases/$(database)/documents/gymbro_rooms/$(roomId)/members/$(request.auth.uid));
        
        // Update/Delete: not allowed (append-only)
        allow update, delete: if false;
      }
      
      // --- Invites Subcollection ---
      // Pending invitations to the room
      match /invites/{inviteId} {
        // Read: invitee can see their own invite, or host can see all
        allow read: if request.auth != null 
                    && (request.auth.uid == resource.data.inviteeUid
                        || get(/databases/$(database)/documents/gymbro_rooms/$(roomId)).data.hostId == request.auth.uid);
        
        // Create: only host can create invites
        allow create: if request.auth != null 
                      && get(/databases/$(database)/documents/gymbro_rooms/$(roomId)).data.hostId == request.auth.uid;
        
        // Update: invitee can update (accept/decline)
        allow update: if request.auth != null && request.auth.uid == resource.data.inviteeUid;
        
        // Delete: host or invitee can delete
        allow delete: if request.auth != null 
                      && (request.auth.uid == resource.data.inviteeUid
                          || get(/databases/$(database)/documents/gymbro_rooms/$(roomId)).data.hostId == request.auth.uid);
      }
    }
    
    // ============================================
    // GYMBRO SOCIAL LAYER - Proximity Logs
    // ============================================
    // Anti-spam debounce for proximity notifications
    // Document ID = sha256(sortedUids.join('_'))
    // Only Cloud Functions can write (via Admin SDK, bypasses rules)
    // Users can read their own proximity logs for history
    match /proximity_logs/{logId} {
      // Read: authenticated users can read (filtered client-side by UID)
      allow read: if request.auth != null;
      
      // Write: DENIED for clients - Cloud Functions use Admin SDK
      // This prevents spam/abuse of proximity notifications
      allow write: if false;
    }
  }
}