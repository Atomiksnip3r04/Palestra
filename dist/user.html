<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Profilo | GYMBRO</title>

    <!-- Open in App Banner for Share Links -->
    <script>
        (function () {
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('s') || urlParams.get('shareId');

            if (shareId && /Android/i.test(navigator.userAgent)) {
                // Check if we're not already in the app (Capacitor)
                const isInApp = window.location.origin.includes('capacitor') ||
                    window.location.origin.includes('localhost');

                if (!isInApp) {
                    // Show banner when DOM is ready
                    document.addEventListener('DOMContentLoaded', function () {
                        const banner = document.createElement('div');
                        banner.id = 'openInAppBanner';
                        banner.innerHTML = `
                        <div style="
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            background: linear-gradient(135deg, #00f3ff, #0066ff);
                            color: white;
                            padding: 12px 16px;
                            z-index: 9999;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            gap: 12px;
                            font-family: 'Inter', sans-serif;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                        ">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 14px;">üì± Hai l'app GymBro?</div>
                                <div style="font-size: 12px; opacity: 0.9;">Apri questa scheda direttamente nell'app</div>
                            </div>
                            <button id="openInAppBtn" style="
                                background: white;
                                color: #0066ff;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 20px;
                                font-weight: 600;
                                font-size: 13px;
                                cursor: pointer;
                                white-space: nowrap;
                            ">Apri App</button>
                            <button id="dismissBannerBtn" style="
                                background: transparent;
                                border: none;
                                color: white;
                                font-size: 20px;
                                cursor: pointer;
                                padding: 4px;
                                opacity: 0.8;
                            ">√ó</button>
                        </div>
                    `;
                        document.body.insertBefore(banner, document.body.firstChild);

                        // Add top padding to body to account for banner
                        document.body.style.paddingTop = '70px';

                        // Open in App button
                        document.getElementById('openInAppBtn').addEventListener('click', function () {
                            const intentUrl = 'intent://workout?id=' + shareId + '#Intent;scheme=gymbro;package=com.gymbro.app;end';
                            window.location.href = intentUrl;
                        });

                        // Dismiss button
                        document.getElementById('dismissBannerBtn').addEventListener('click', function () {
                            banner.remove();
                            document.body.style.paddingTop = '';
                        });
                    });
                }
            }
        })();
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Oswald:wght@500;700&display=swap"
        rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00f3ff">

    <!-- iOS Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GymBro">
    <link rel="apple-touch-icon" href="assets/icon.svg">

    <link rel="icon" type="image/svg+xml" href="assets/icon.svg">
    <link rel="stylesheet" href="css/style.css">
    <style>
        /* =========================
           PAGE-WIDE SYMMETRY
           ========================= */
        .profile-section-container {
            padding: 0 var(--page-padding, 1rem);
        }
        
        /* =========================
           PROFILE HEADER
           ========================= */
        .profile-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .avatar-container {
            position: relative;
            cursor: pointer;
        }

        .avatar {
            width: 72px;
            height: 72px;
            background: linear-gradient(145deg, var(--color-surface), rgba(0,0,0,0.3));
            border: 3px solid var(--color-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: var(--color-primary);
            overflow: hidden;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.25), inset 0 0 15px rgba(0, 243, 255, 0.1);
        }

        .avatar-overlay {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: linear-gradient(135deg, var(--color-primary), #00c8d4);
            color: black;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            border: 3px solid var(--color-bg);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* =========================
           SETTING ITEMS - Professionali
           ========================= */
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            font-weight: 500;
            color: var(--color-text-main);
            flex-shrink: 0;
            font-size: 0.9rem;
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-grow: 1;
            justify-content: flex-end;
        }
        
        /* Input Group Professionale - Inline */
        .input-group-inline {
            display: flex;
            align-items: stretch;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .input-group-inline:focus-within {
            border-color: var(--color-primary);
        }
        
        .input-group-inline input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            padding: 0.6rem 0.75rem;
            font-size: 0.85rem;
            min-width: 0;
        }
        
        .input-group-inline input:focus {
            outline: none;
        }
        
        .input-group-inline .btn-inline-save {
            background: var(--color-primary);
            color: var(--color-bg);
            border: none;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: background 0.2s;
        }
        
        .input-group-inline .btn-inline-save:hover {
            background: #00d4e0;
        }
        
        .input-group-inline .password-toggle-inline {
            background: transparent;
            border: none;
            color: var(--color-text-muted);
            padding: 0 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        /* Health Connect Toggle Style */
        .health-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-bottom: 0.75rem;
        }
        
        .health-toggle-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch.active {
            background: var(--color-primary);
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .toggle-switch.active::after {
            transform: translateX(22px);
        }

        .input-compact {
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--color-border);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
        }

        .btn-compact {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            min-width: 80px;
        }
        
        /* Logout Button - Ridotto */
        .btn-logout {
            background: transparent;
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 0.6rem 1.5rem;
            font-size: 0.85rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            width: auto;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-logout:hover {
            background: rgba(255, 68, 68, 0.15);
        }

        .doms-chip-grid {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 0.35rem;
        }

        .doms-chip-group {
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: var(--color-text-muted);
        }

        .doms-chip-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }

        .wellness-modal {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2100;
            padding: clamp(0.75rem, 4vw, 1.5rem);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            backdrop-filter: blur(8px);
        }

        .wellness-modal-card {
            width: min(100%, 440px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-md);
            max-height: calc(100vh - clamp(1.5rem, 6vh, 3rem));
            overflow-y: auto;
            padding: clamp(1rem, 3vw, 1.5rem);
            background: var(--color-surface);
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
            scrollbar-width: thin;
            scrollbar-color: var(--color-primary) rgba(255, 255, 255, 0.1);
        }

        .wellness-modal-card::-webkit-scrollbar {
            width: 6px;
        }

        .wellness-modal-card::-webkit-scrollbar-track {
            background: transparent;
        }

        .wellness-modal-card::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.25);
            border-radius: 999px;
        }

        @media (max-width: 640px) {
            .wellness-modal {
                align-items: flex-start;
            }

            .wellness-modal-card {
                max-height: calc(100vh - 1.5rem);
            }
        }

        .doms-chip {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #fff;
            border-radius: 999px;
            padding: 0.3rem 0.8rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .doms-chip.active {
            background: rgba(0, 243, 255, 0.25);
            color: #000;
            border-color: rgba(0, 243, 255, 0.6);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        .doms-chip:focus-visible {
            outline: 2px solid var(--color-primary);
            outline-offset: 2px;
        }

        .doms-chip-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--color-text-muted);
            margin-top: 0.4rem;
        }

        /* Wellness Step Buttons (1-10) */
        .wellness-grid-2x2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .wellness-field {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }
        
        .wellness-field-label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            color: var(--color-text);
        }
        
        .wellness-field-label .emoji {
            font-size: 1rem;
        }
        
        .step-buttons-row {
            display: flex;
            gap: 2px;
        }
        
        .step-btn {
            flex: 1;
            min-width: 0;
            height: 32px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .step-btn:first-child {
            border-radius: 6px 0 0 6px;
        }
        
        .step-btn:last-child {
            border-radius: 0 6px 6px 0;
        }
        
        .step-btn.active {
            background: var(--color-primary);
            color: #000;
            font-weight: 600;
        }
        
        .step-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* Color gradient for step buttons based on value */
        .step-btn.active[data-value="1"],
        .step-btn.active[data-value="2"] {
            background: #ef4444;
            color: #fff;
        }
        
        .step-btn.active[data-value="3"],
        .step-btn.active[data-value="4"] {
            background: #f97316;
            color: #fff;
        }
        
        .step-btn.active[data-value="5"],
        .step-btn.active[data-value="6"] {
            background: #eab308;
            color: #000;
        }
        
        .step-btn.active[data-value="7"],
        .step-btn.active[data-value="8"] {
            background: #22c55e;
            color: #fff;
        }
        
        .step-btn.active[data-value="9"],
        .step-btn.active[data-value="10"] {
            background: var(--color-primary);
            color: #000;
        }
        
        /* Inverted colors for stress and DOMS (lower is better) */
        .step-btn.inverted.active[data-value="1"],
        .step-btn.inverted.active[data-value="2"] {
            background: var(--color-primary);
            color: #000;
        }
        
        .step-btn.inverted.active[data-value="3"],
        .step-btn.inverted.active[data-value="4"] {
            background: #22c55e;
            color: #fff;
        }
        
        .step-btn.inverted.active[data-value="5"],
        .step-btn.inverted.active[data-value="6"] {
            background: #eab308;
            color: #000;
        }
        
        .step-btn.inverted.active[data-value="7"],
        .step-btn.inverted.active[data-value="8"] {
            background: #f97316;
            color: #fff;
        }
        
        .step-btn.inverted.active[data-value="9"],
        .step-btn.inverted.active[data-value="10"] {
            background: #ef4444;
            color: #fff;
        }
        
        /* DOMS Muscle Category Separators */
        .doms-category-section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .doms-category-section:last-child {
            margin-bottom: 0;
        }
        
        .doms-chip-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.35rem;
        }
        
        .doms-chip {
            text-align: center;
            padding: 0.35rem 0.5rem;
            font-size: 0.72rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Expandable notes field */
        .notes-expandable {
            min-height: 36px;
            max-height: 36px;
            resize: none;
            transition: max-height 0.2s ease;
            overflow: hidden;
        }
        
        .notes-expandable:focus,
        .notes-expandable.has-content {
            max-height: 80px;
            overflow-y: auto;
        }

        /* Mobile specific adjustments for settings */
        @media (max-width: 480px) {
            .setting-item {
                flex-direction: column;
                align-items: stretch;
            }

            .setting-control {
                width: 100%;
                justify-content: stretch;
            }

            .setting-control input,
            .setting-control select,
            .setting-control button {
                width: 100%;
            }

            .setting-control form {
                width: 100%;
            }
        }

        /* =========================
           WORKOUT LIST ITEMS - Compatte
           ========================= */
        .workout-list-item {
            background: linear-gradient(145deg, var(--color-surface) 0%, rgba(0,0,0,0.2) 100%);
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
        }

        .workout-list-item:hover {
            border-color: rgba(0, 243, 255, 0.2);
        }

        .workout-list-item:active {
            transform: scale(0.98);
        }

        .workout-list-item .workout-header {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            width: 100%;
        }

        .workout-list-item .workout-title {
            font-weight: 600;
            font-size: 1rem;
            line-height: 1.25;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }
        
        /* Badge AI integrato inline */
        .workout-list-item .ai-badge {
            font-size: 0.6rem;
            padding: 0.1rem 0.35rem;
        }

        /* Meta dati su una riga */
        .workout-list-item .workout-meta {
            font-size: 0.75rem;
            color: var(--color-text-muted);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .workout-list-item .workout-meta .meta-separator {
            width: 3px;
            height: 3px;
            background: var(--color-text-muted);
            border-radius: 50%;
            opacity: 0.5;
        }

        .workout-list-item .workout-date {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        /* Action Bar Uniformata */
        .workout-list-item .workout-actions {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding-top: 0.6rem;
            border-top: 1px solid rgba(255, 255, 255, 0.06);
        }

        .workout-list-item .btn-play {
            background: linear-gradient(135deg, var(--color-primary) 0%, #00d4e0 100%);
            color: black;
            border: none;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.15s, box-shadow 0.15s;
            box-shadow: 0 3px 12px rgba(0, 243, 255, 0.3);
            flex-shrink: 0;
        }

        .workout-list-item .btn-play:hover {
            transform: scale(1.08);
        }

        .workout-list-item .btn-play:active {
            transform: scale(0.95);
        }
        
        /* Spacer per pushare icone a destra */
        .workout-actions-spacer {
            flex: 1;
        }

        /* Gruppo icone azione uniformate a destra */
        .workout-action-icons {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .workout-list-item .btn-icon-action {
            padding: 0.45rem;
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.6;
            transition: all 0.15s;
            border-radius: 8px;
            flex-shrink: 0;
            background: transparent;
            border: none;
        }

        .workout-list-item .btn-icon-action:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.08);
        }

        .workout-list-item .btn-icon-action.delete {
            color: #ff4444;
        }

        .workout-list-item .btn-icon-action.delete:hover {
            background: rgba(255, 68, 68, 0.12);
        }
        
        /* Rimuovo btn-edit testuale, ora √® icona */
        .workout-list-item .btn-edit {
            display: none;
        }

        /* Auth Forms */
        .auth-container {
            display: none;
            /* Hidden by default */
        }

        .profile-content {
            display: none;
            /* Hidden by default */
        }

        .visible {
            display: block;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--color-text-muted);
        }

        .form-group input {
            width: 100%;
            padding: 0.8rem;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            color: var(--color-text);
        }

        .text-center {
            text-align: center;
        }

        .link-btn {
            background: none;
            border: none;
            color: var(--color-primary);
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
            font-size: 0.9rem;
        }

        .ai-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(0, 243, 255, 0.15);
            color: var(--color-primary);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 999px;
            font-size: 0.65rem;
            padding: 0 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .ai-plan-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: clamp(0.75rem, 3vw, 1rem);
        }

        .ai-plan-section {
            margin-top: 1rem;
        }

        .ai-plan-section h5 {
            margin: 0;
            font-size: clamp(0.8rem, 2.8vw, 0.85rem);
            color: var(--color-text-muted);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            line-height: 1.3;
        }

        .ai-plan-section ul {
            margin: 0.5rem 0 0;
            padding-left: 1.2rem;
            color: #ddd;
            font-size: clamp(0.85rem, 2.8vw, 0.9rem);
            line-height: 1.5;
        }

        .ai-plan-section li {
            margin-bottom: 0.4rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .btn-compact {
            padding: 0.3rem 0.8rem;
            font-size: clamp(0.75rem, 2.5vw, 0.85rem);
        }
        
        /* Highlight animation for scroll target */
        @keyframes highlightPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 243, 255, 0); }
            50% { box-shadow: 0 0 0 8px rgba(0, 243, 255, 0.3); }
        }
        
        .highlight-target {
            animation: highlightPulse 1s ease-in-out 2;
            border-color: var(--color-primary) !important;
        }
    </style>
    
    <!-- Hash scroll handler -->
    <script>
        // Scroll to hash target when page loads (for links like user.html#healthConnect)
        let scrollAttempts = 0;
        const MAX_SCROLL_ATTEMPTS = 20;
        
        function scrollToHashTarget() {
            if (!window.location.hash) return;
            
            const targetId = window.location.hash.substring(1);
            const targetEl = document.getElementById(targetId);
            
            if (!targetEl) {
                console.log('Hash target element not found:', targetId);
                return;
            }
            
            // Check if element is visible (not hidden by auth state)
            const profileContent = document.getElementById('profileContent');
            const isProfileVisible = profileContent && profileContent.classList.contains('visible');
            
            if (!isProfileVisible && scrollAttempts < MAX_SCROLL_ATTEMPTS) {
                scrollAttempts++;
                setTimeout(scrollToHashTarget, 250);
                return;
            }
            
            // Check if target is inside a collapsed dropdown (settingsContent)
            const settingsContent = document.getElementById('settingsContent');
            const settingsHeader = document.getElementById('settingsHeader');
            const settingsToggle = document.getElementById('settingsToggle');
            
            if (settingsContent && settingsContent.contains(targetEl)) {
                // Open the dropdown first
                if (settingsContent.style.display === 'none') {
                    settingsContent.style.display = 'block';
                    if (settingsToggle) settingsToggle.style.transform = 'rotate(180deg)';
                }
            }
            
            // Wait a tick for layout to update after opening dropdown
            setTimeout(() => {
                const rect = targetEl.getBoundingClientRect();
                const isElementVisible = rect.width > 0 && rect.height > 0;
                
                if (isElementVisible) {
                    scrollAttempts = 0;
                    targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    targetEl.classList.add('highlight-target');
                    setTimeout(() => targetEl.classList.remove('highlight-target'), 2500);
                    console.log('Scrolled to:', targetId);
                } else if (scrollAttempts < MAX_SCROLL_ATTEMPTS) {
                    scrollAttempts++;
                    setTimeout(scrollToHashTarget, 250);
                }
            }, 100);
        }
        
        // Wait for DOM and initial render
        window.addEventListener('load', function() {
            // Start checking after short initial delay
            setTimeout(scrollToHashTarget, 300);
        });
        
        // Also listen for hashchange (in case user clicks link while on page)
        window.addEventListener('hashchange', function() {
            scrollAttempts = 0;
            setTimeout(scrollToHashTarget, 100);
        });
    </script>
</head>

<body>

    <header class="header">
        <div class="container">
            <a href="index.html" class="logo">GYM<span class="text-primary">BRO</span></a>
            <nav>
                <div class="mobile-toggle" id="mobileToggle">‚ò∞</div>
                <ul class="nav-links" id="navLinks">
                    <li><a href="creator.html">üìù Crea Schede</a></li>
                    <li><a href="diary.html">üìì Diario</a></li>
                    <li><a href="analysis.html">üìà Analisi</a></li>
                    <li><a href="body.html">üí™ Corpo</a></li>
                    <li><a href="user.html" class="text-primary">üë§ Profilo</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section class="section" style="padding-top: 160px;">
        <div class="container">

            <!-- Auth Section (Login/Register) -->
            <div id="authSection" class="auth-container card" style="max-width: 400px; margin: 0 auto 2rem auto;">
                <h3 id="authTitle" class="text-center" style="margin-bottom: 1.5rem;">Accedi</h3>

                <form id="authForm">
                    <div class="form-group" id="nameGroup" style="display: none;">
                        <label>Nome</label>
                        <input type="text" id="nameInput" placeholder="Il tuo nome" autocomplete="name">
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="emailInput" required placeholder="email@esempio.com"
                            autocomplete="email">
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <div class="password-wrapper">
                            <input type="password" id="passwordInput" required placeholder="******"
                                autocomplete="current-password">
                            <button type="button" class="password-toggle" title="Mostra password">üëÅÔ∏è</button>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary" style="width: 100%; margin-top: 1rem;">Entra</button>
                </form>

                <p class="text-center" style="margin-top: 1rem; font-size: 0.9rem;">
                    <span id="authSwitchText">Non hai un account?</span>
                    <button id="authSwitchBtn" class="link-btn">Registrati</button>
                </p>
                <p id="authError" style="color: #ff4444; font-size: 0.9rem; text-align: center; margin-top: 1rem;"></p>
            </div>


            <!-- Profile Content (Logged In) -->
            <div id="profileContent" class="profile-content">
                <!-- Profile Header -->
                <div class="profile-header">
                    <div class="avatar-container" id="avatarContainer">
                        <div class="avatar" id="profileAvatar">üë§</div>
                        <div class="avatar-overlay">üì∑</div>
                        <input type="file" id="photoInput" accept="image/*" style="display: none;">
                    </div>
                    <div>
                        <h2 id="profileNameDisplay">Atleta <span class="text-primary">Pro</span></h2>
                        <p id="profileEmailDisplay" style="font-size: 0.9rem; color: var(--color-text-muted);">...</p>
                    </div>
                </div>

                <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">

                    <!-- Saved Workouts -->
                    <div>
                        <!-- AI GENERATOR - Now in Creator Page -->
                        <a href="creator.html" class="card" style="display: block; margin-bottom: 2rem; border-radius: 16px; border: 1px solid rgba(0, 243, 255, 0.2); background: linear-gradient(145deg, rgba(0, 243, 255, 0.08) 0%, rgba(0, 150, 170, 0.03) 50%, rgba(0,0,0,0.1) 100%); text-decoration: none; padding: 1rem; transition: all 0.2s;">
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <div style="width: 45px; height: 45px; border-radius: 12px; background: linear-gradient(135deg, var(--color-primary) 0%, #00c8d4 100%); display: flex; align-items: center; justify-content: center; font-size: 1.3rem; box-shadow: 0 4px 12px rgba(0, 243, 255, 0.3);">
                                    ü§ñ
                                </div>
                                <div style="flex: 1;">
                                    <h3 style="font-size: 1rem; margin: 0; font-weight: 600; color: white;">AI Workout Generator</h3>
                                    <p style="font-size: 0.75rem; color: var(--color-text-muted); margin: 0.2rem 0 0 0;">
                                        Genera schede personalizzate con Gemini AI ‚Üí
                                    </p>
                                </div>
                            </div>
                        </a>

                        <h3 style="margin-bottom: 1rem;">Le tue Schede</h3>
                        <div id="savedWorkoutsList">
                            <!-- Dynamic List -->
                        </div>
                        <a href="creator.html" class="btn btn-outline" style="width: 100%; margin-top: 1rem;">+ Nuova
                            Scheda</a>
                    </div>

                    <!-- Settings -->
                    <div class="card">
                        <div style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding-bottom: 1rem; border-bottom: 1px solid var(--color-border);" id="settingsHeader">
                            <h3 style="margin: 0;">‚öôÔ∏è Impostazioni</h3>
                            <span id="settingsToggle" style="font-size: 1.5rem; transition: transform 0.3s;">‚ñº</span>
                        </div>

                        <div id="settingsContent" style="display: none; margin-top: 1rem;">
                        <div class="setting-item">
                            <span class="setting-label">Nome Visualizzato</span>
                            <div class="setting-control">
                                <input type="text" id="profileNameInput" class="input-compact"
                                    style="width: 100%; max-width: 200px;">
                            </div>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Unit√† di misura</span>
                            <div class="setting-control">
                                <select class="input-compact" style="width: 100%; max-width: 200px;">
                                    <option>Metrico (kg/cm)</option>
                                    <option>Imperiale (lbs/in)</option>
                                </select>
                            </div>
                        </div>

                        <!-- AI CONFIG SECTION - Input Group Inline -->
                        <div class="setting-item">
                            <div style="width: 100%; display: flex; flex-direction: column; gap: 0.4rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span class="setting-label">Gemini AI Key</span>
                                    <a href="https://aistudio.google.com/app/apikey" target="_blank"
                                        style="font-size: 0.7rem; color: var(--color-primary);">Ottieni Key ‚Üí</a>
                                </div>
                                <div class="input-group-inline">
                                    <input type="password" id="aiKeyInput" placeholder="Incolla la tua API Key" autocomplete="off">
                                    <button type="button" class="password-toggle-inline" title="Mostra">üëÅÔ∏è</button>
                                    <button id="saveAiKeyBtn" type="button" class="btn-inline-save">Salva</button>
                                </div>
                                <p id="aiKeyStatus" style="font-size: 0.7rem; color: var(--color-text-muted); margin: 0; min-height: 1em;"></p>
                            </div>
                        </div>

                        <!-- IMGBB CONFIG SECTION - Input Group Inline -->
                        <div class="setting-item">
                            <div style="width: 100%; display: flex; flex-direction: column; gap: 0.4rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span class="setting-label">ImgBB API Key</span>
                                    <a href="https://api.imgbb.com/" target="_blank"
                                        style="font-size: 0.7rem; color: var(--color-primary);">Ottieni Key ‚Üí</a>
                                </div>
                                <div class="input-group-inline">
                                    <input type="password" id="imgbbKeyInput" placeholder="Incolla la tua API Key" autocomplete="off">
                                    <button type="button" class="password-toggle-inline" title="Mostra">üëÅÔ∏è</button>
                                    <button id="saveImgbbKeyBtn" type="button" class="btn-inline-save">Salva</button>
                                </div>
                                <p id="imgbbKeyStatus" style="font-size: 0.7rem; color: var(--color-text-muted); margin: 0; min-height: 1em;"></p>
                            </div>
                        </div>

                        <!-- Health Connect Section - Design Pulito -->
                        <div id="healthConnect" class="setting-item" style="flex-direction: column; align-items: stretch;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <span style="font-size: 1.2rem;">üè•</span>
                                <span class="setting-label" style="font-size: 0.95rem;">Connessione Salute</span>
                            </div>

                            <div id="healthConnectStatus" class="health-toggle-container">
                                <div class="health-toggle-label">
                                    <span id="healthStatusIcon">‚ö™</span>
                                    <span id="healthStatusText" style="font-size: 0.85rem;">Non connesso</span>
                                </div>
                                <div id="healthToggleSwitch" class="toggle-switch" role="switch" aria-checked="false"></div>
                            </div>
                            
                            <small id="healthLastSync" style="font-size: 0.7rem; color: var(--color-text-muted); display: none;">
                                Ultimo sync: <span id="lastSyncTime"></span>
                            </small>

                            <!-- Provider Selection (shown when not connected) -->
                            <div id="healthProviderSelection" style="margin-top: 0.5rem;">
                                <p style="font-size: 0.75rem; color: var(--color-text-muted); margin-bottom: 0.5rem;">
                                    Scegli il provider:
                                </p>
                                <div style="display: flex; gap: 0.4rem;">
                                    <button id="connectGoogleFitBtn" class="btn btn-outline btn-compact"
                                        style="flex: 1; font-size: 0.75rem; padding: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 0.3rem;">
                                        ü§ñ Google Fit
                                    </button>
                                    <button id="connectAppleHealthBtn" class="btn btn-outline btn-compact"
                                        style="flex: 1; font-size: 0.75rem; padding: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 0.3rem;">
                                        üçé Apple Health
                                    </button>
                                </div>
                            </div>

                            <!-- Connected Actions (shown when connected) -->
                            <div id="healthConnectedActions" style="display: none; margin-top: 0.5rem;">
                                <div style="display: flex; gap: 0.4rem;">
                                    <button id="syncHealthBtn" class="btn btn-primary btn-compact"
                                        style="flex: 1; font-size: 0.75rem; padding: 0.5rem;">
                                        üîÑ Sincronizza
                                    </button>
                                    <button id="disconnectHealthBtn" class="btn btn-outline btn-compact"
                                        style="flex: 1; font-size: 0.75rem; padding: 0.5rem; color: #ff4444; border-color: rgba(255,68,68,0.3);">
                                        Disconnetti
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="setting-item">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; width: 100%; flex-wrap: wrap; gap: 0.5rem;">
                                <span class="setting-label">Sincronizzazione</span>
                                <div class="setting-control" style="width: auto; justify-content: flex-end;">
                                    <button id="syncBtn" class="btn btn-outline btn-compact">Sincronizza Ora</button>
                                </div>
                            </div>
                            <p id="syncStatus"
                                style="font-size: 0.75rem; color: var(--color-text-muted); width: 100%; text-align: right; margin-top: 0.25rem;">
                            </p>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Esporta Dati (JSON)</span>
                            <div class="setting-control">
                                <button id="exportBtn" class="btn btn-outline btn-compact">Download</button>
                            </div>
                        </div>

                        <div class="setting-item" style="border-bottom: none; margin-top: 1rem; justify-content: center;">
                            <button id="logoutBtn" class="btn-logout">üö™ Esci</button>
                        </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Edit Rest Times Modal -->
    <div id="editRestModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; align-items: center; justify-content: center; padding: clamp(0.5rem, 2vw, 1rem); overflow-y: auto;">
        <div class="card"
            style="max-width: 500px; width: 100%; max-height: 90vh; overflow-y: auto; position: relative; margin: auto; border-radius: 20px;">
            <button id="closeEditRestModal"
                style="position: sticky; top: 0; right: 0; float: right; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); color: white; font-size: 1.5rem; cursor: pointer; width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 10; margin-bottom: -36px;">&times;</button>
            <h3 style="margin-bottom: 0.5rem; font-size: clamp(1.1rem, 4vw, 1.3rem); padding-right: 40px;">
                ‚è±Ô∏è Modifica <span class="text-primary">Recuperi</span>
            </h3>
            <p style="font-size: 0.8rem; color: var(--color-text-muted); margin-bottom: 1rem;">
                Imposta i tempi di recupero personalizzati per ogni serie
            </p>
            <div id="editRestWorkoutName" style="font-weight: 600; margin-bottom: 1rem; padding: 0.5rem; background: rgba(0,243,255,0.1); border-radius: 8px;"></div>
            <div id="editRestContent" style="display: flex; flex-direction: column; gap: 1rem;">
                <!-- Dynamic content -->
            </div>
            <div style="display: flex; gap: 0.75rem; margin-top: 1.5rem;">
                <button id="cancelEditRest" class="btn btn-outline" style="flex: 1; border-radius: 10px;">Annulla</button>
                <button id="saveEditRest" class="btn btn-primary" style="flex: 2; border-radius: 10px;">üíæ Salva Modifiche</button>
            </div>
        </div>
    </div>

    <!-- Wellness Prompt Modal -->
    <div id="wellnessPromptModal" class="wellness-modal" role="dialog" aria-modal="true"
        aria-labelledby="wellnessPromptTitle" style="display:none;">
        <div class="card wellness-modal-card">
            <h3 id="wellnessPromptTitle" style="margin-bottom:0.25rem; font-size: 1.1rem;">üèãÔ∏è Pre-Allenamento</h3>
            <p style="color: var(--color-text-muted); font-size:0.75rem; margin-bottom:0.75rem;">Check rapido: valuta il tuo stato (1-10)</p>
            
            <form id="wellnessForm" style="display:flex; flex-direction:column; gap:0.6rem;">
                <!-- Wellness Grid 2x2 -->
                <div class="wellness-grid-2x2">
                    <!-- Sonno -->
                    <div class="wellness-field">
                        <div class="wellness-field-label">
                            <span class="emoji">üò¥</span>
                            <span>Sonno</span>
                        </div>
                        <div class="step-buttons-row" data-target="sleepQualityInput">
                            <button type="button" class="step-btn" data-value="1">1</button>
                            <button type="button" class="step-btn" data-value="2">2</button>
                            <button type="button" class="step-btn" data-value="3">3</button>
                            <button type="button" class="step-btn" data-value="4">4</button>
                            <button type="button" class="step-btn" data-value="5">5</button>
                            <button type="button" class="step-btn" data-value="6">6</button>
                            <button type="button" class="step-btn active" data-value="7">7</button>
                            <button type="button" class="step-btn" data-value="8">8</button>
                            <button type="button" class="step-btn" data-value="9">9</button>
                            <button type="button" class="step-btn" data-value="10">10</button>
                        </div>
                        <input type="hidden" id="sleepQualityInput" value="7">
                    </div>
                    
                    <!-- Energia -->
                    <div class="wellness-field">
                        <div class="wellness-field-label">
                            <span class="emoji">‚ö°</span>
                            <span>Energia</span>
                        </div>
                        <div class="step-buttons-row" data-target="energyLevelInput">
                            <button type="button" class="step-btn" data-value="1">1</button>
                            <button type="button" class="step-btn" data-value="2">2</button>
                            <button type="button" class="step-btn" data-value="3">3</button>
                            <button type="button" class="step-btn" data-value="4">4</button>
                            <button type="button" class="step-btn" data-value="5">5</button>
                            <button type="button" class="step-btn" data-value="6">6</button>
                            <button type="button" class="step-btn active" data-value="7">7</button>
                            <button type="button" class="step-btn" data-value="8">8</button>
                            <button type="button" class="step-btn" data-value="9">9</button>
                            <button type="button" class="step-btn" data-value="10">10</button>
                        </div>
                        <input type="hidden" id="energyLevelInput" value="7">
                    </div>
                    
                    <!-- Stress -->
                    <div class="wellness-field">
                        <div class="wellness-field-label">
                            <span class="emoji">üßò</span>
                            <span>Stress</span>
                        </div>
                        <div class="step-buttons-row" data-target="stressLevelInput" data-inverted="true">
                            <button type="button" class="step-btn inverted" data-value="1">1</button>
                            <button type="button" class="step-btn inverted" data-value="2">2</button>
                            <button type="button" class="step-btn inverted" data-value="3">3</button>
                            <button type="button" class="step-btn inverted active" data-value="4">4</button>
                            <button type="button" class="step-btn inverted" data-value="5">5</button>
                            <button type="button" class="step-btn inverted" data-value="6">6</button>
                            <button type="button" class="step-btn inverted" data-value="7">7</button>
                            <button type="button" class="step-btn inverted" data-value="8">8</button>
                            <button type="button" class="step-btn inverted" data-value="9">9</button>
                            <button type="button" class="step-btn inverted" data-value="10">10</button>
                        </div>
                        <input type="hidden" id="stressLevelInput" value="4">
                    </div>
                    
                    <!-- DOMS -->
                    <div class="wellness-field">
                        <div class="wellness-field-label">
                            <span class="emoji">üí™</span>
                            <span>DOMS</span>
                        </div>
                        <div class="step-buttons-row" data-target="sorenessLevelInput" data-inverted="true">
                            <button type="button" class="step-btn inverted" data-value="1">1</button>
                            <button type="button" class="step-btn inverted" data-value="2">2</button>
                            <button type="button" class="step-btn inverted active" data-value="3">3</button>
                            <button type="button" class="step-btn inverted" data-value="4">4</button>
                            <button type="button" class="step-btn inverted" data-value="5">5</button>
                            <button type="button" class="step-btn inverted" data-value="6">6</button>
                            <button type="button" class="step-btn inverted" data-value="7">7</button>
                            <button type="button" class="step-btn inverted" data-value="8">8</button>
                            <button type="button" class="step-btn inverted" data-value="9">9</button>
                            <button type="button" class="step-btn inverted" data-value="10">10</button>
                        </div>
                        <input type="hidden" id="sorenessLevelInput" value="3">
                    </div>
                </div>
                
                <!-- DOMS Muscle Selection -->
                <div style="margin-top: 0.25rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                        <span style="font-size: 0.8rem; color: var(--color-text);">Muscoli con DOMS</span>
                        <button type="button" id="clearSorenessSelection" class="link-btn" style="font-size: 0.7rem;">Azzera</button>
                    </div>
                    <div id="sorenessMusclePicker" class="doms-chip-grid" role="listbox" aria-multiselectable="true">
                    </div>
                    <small id="sorenessMuscleHint" style="font-size: 0.7rem; color: var(--color-text-muted); display: block; margin-top: 0.3rem;">Nessun distretto selezionato</small>
                </div>
                
                <!-- Notes field (expandable) -->
                <div style="margin-top: 0.25rem;">
                    <label style="font-size: 0.8rem; color: var(--color-text); display: block; margin-bottom: 0.25rem;">
                        Causa DOMS <span style="color: var(--color-text-muted); font-size: 0.7rem;">(opzionale)</span>
                    </label>
                    <textarea id="domsExternalCauseInput" class="input-compact notes-expandable"
                        style="width: 100%; font-size: 0.8rem;"
                        placeholder="es. Padel, corsa, lavoro fisico..."
                        rows="1"></textarea>
                </div>
                
                <!-- CTA Footer -->
                <div style="margin-top: 0.75rem;">
                    <button type="submit" class="btn btn-primary" style="width: 100%; padding: 0.85rem; font-size: 0.95rem; font-weight: 600; border-radius: 10px;">
                        üöÄ INIZIA FOCUS MODE
                    </button>
                    <button type="button" id="cancelWellnessBtn" style="width: 100%; margin-top: 0.5rem; background: none; border: none; color: var(--color-text-muted); font-size: 0.8rem; cursor: pointer; padding: 0.5rem;">
                        Annulla
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Focus Mode Overlay -->
    <div id="focusModeOverlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; flex-direction: column; padding: env(safe-area-inset-top, 1rem) 1.5rem env(safe-area-inset-bottom, 1rem) 1.5rem;">
        <!-- Top Bar -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <div style="display:flex; flex-direction:column;">
                <div style="font-family: var(--font-display); font-size: 1.2rem; color: var(--color-primary);">FOCUS
                    FLOW</div>
                <div id="focusWorkoutTitle" style="font-size: 0.8rem; color: var(--color-text-muted);">Workout</div>
            </div>
            <button id="exitFocusMode"
                style="background: none; border: 1px solid #333; color: #fff; width: 40px; height: 40px; border-radius: 50%; font-size: 1.2rem; cursor: pointer;">‚úï</button>
        </div>

        <!-- Main Content (Scrollable) -->
        <div id="focusContentWrapper"
            style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; width: 100%; max-width: 500px; margin: 0 auto; overflow-y: auto; overflow-x: hidden; padding-top: 1rem; padding-bottom: 40px;">

            <!-- Exercise Info -->
            <div style="text-align: center; margin-bottom: 2rem; width: 100%;">
                <h2 id="focusExerciseName" style="font-size: 2rem; margin-bottom: 0.5rem; line-height: 1.1;">Esercizio
                </h2>
                <div
                    style="font-size: 1.1rem; color: var(--color-text-muted); display: flex; justify-content: center; gap: 1rem;">
                    <span id="focusSetCounter">Set 1 / 3</span>
                </div>
            </div>

            <!-- Active Inputs Area -->
            <div id="focusActiveArea" style="width: 100%; margin-bottom: 2rem;">
                <!-- Bilateral Dumbbell Indicator -->
                <div id="focusBilateralIndicator"
                    style="display: none; background: linear-gradient(135deg, rgba(156,39,176,0.15), rgba(103,58,183,0.1)); border: 1px solid rgba(156,39,176,0.3); border-radius: var(--radius-md); padding: 0.5rem 1rem; margin-bottom: 0.75rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span style="font-size: 1rem;">üèãÔ∏è</span>
                        <span style="color: #ce93d8; font-size: 0.8rem; font-weight: 500;">Manubri Bilaterali</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;">‚Ä¢ Inserisci peso singolo
                            manubrio</span>
                    </div>
                </div>
                <!-- Unilateral Mode Toggle (Single Arm) -->
                <div id="focusUnilateralToggle" style="display: none; margin-bottom: 0.75rem;">
                    <label
                        style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.6rem 1rem; background: linear-gradient(135deg, rgba(255,152,0,0.12), rgba(255,193,7,0.08)); border: 1px solid rgba(255,152,0,0.35); border-radius: var(--radius-md); transition: all 0.2s ease;">
                        <div
                            style="position: relative; width: 44px; height: 24px; background: rgba(255,255,255,0.1); border-radius: 12px; transition: background 0.2s;">
                            <input type="checkbox" id="unilateralToggleCheckbox"
                                style="opacity: 0; position: absolute; width: 100%; height: 100%; cursor: pointer; z-index: 2;">
                            <div id="unilateralToggleTrack"
                                style="position: absolute; width: 100%; height: 100%; background: rgba(255,255,255,0.15); border-radius: 12px; transition: background 0.2s;">
                            </div>
                            <div id="unilateralToggleThumb"
                                style="position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.2s, background 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.1rem;">
                            <span
                                style="color: #ff9800; font-size: 0.85rem; font-weight: 600; display: flex; align-items: center; gap: 0.4rem;">
                                üí™ Modalit√† Braccio Singolo
                            </span>
                            <span style="color: var(--color-text-muted); font-size: 0.7rem;">
                                Traccia pesi diversi per DX e SX
                            </span>
                        </div>
                    </label>
                </div>
                <!-- Suggested Weight Banner -->
                <div id="focusSuggestedWeight"
                    style="display: none; background: linear-gradient(135deg, rgba(0,243,255,0.15), rgba(0,153,255,0.1)); border: 1px solid rgba(0,243,255,0.3); border-radius: var(--radius-md); padding: 0.6rem 1rem; margin-bottom: 1rem; text-align: center;">
                    <div
                        style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; flex-wrap: wrap;">
                        <span style="color: var(--color-text-muted); font-size: 0.75rem;">üí° Suggerito:</span>
                        <span id="focusSuggestedValue"
                            style="color: var(--color-primary); font-weight: bold; font-size: 1.1rem;">--</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;"
                            id="focusSuggestedBasis">(basato su storico)</span>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; margin-bottom: 1.5rem;">
                    <div
                        style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label id="focusWeightLabel"
                            style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">KG</label>
                        <input type="number" id="focusWeightInput"
                            style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);"
                            value="">
                    </div>
                    <div
                        style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label
                            style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">REPS</label>
                        <input type="number" id="focusRepsInput" inputmode="numeric" min="1" step="1"
                            style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);"
                            value="">
                    </div>
                    <div
                        style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label
                            style="display: flex; align-items: center; justify-content: center; gap: 0.3rem; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">
                            RPE
                            <span onclick="openRpeInfoModal()" style="cursor: pointer; border: 1px solid var(--color-primary); border-radius: 50%; width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; font-size: 0.55rem; color: var(--color-primary); background: rgba(0, 243, 255, 0.1);">?</span>
                        </label>
                        <input type="number" id="focusRpeInput" min="6" max="10" step="0.5"
                            style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);"
                            value="" placeholder="6-10">
                    </div>
                </div>
            </div>

            <!-- Timer Area (Hidden by default) -->
            <div id="focusTimerArea" style="display: none; text-align: center; margin-bottom: 2rem; width: 100%;">
                <div style="color: var(--color-text-muted); margin-bottom: 0.5rem;">RECUPERO</div>
                <div id="focusTimer"
                    style="font-family: monospace; font-size: 4.5rem; color: white; line-height: 1; margin-bottom: 1rem;">
                    00:00</div>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button class="btn-timer-adjust" onclick="adjustTimer(-10)">-10s</button>
                    <button class="btn-timer-adjust" onclick="adjustTimer(+10)">+10s</button>
                    <button class="btn-timer-adjust" onclick="skipRest()">Salta</button>
                </div>
            </div>

            <!-- Action Button -->
            <button id="focusActionBtn" class="btn btn-primary"
                style="width: 100%; height: 70px; font-size: 1.4rem; border-radius: 12px; box-shadow: 0 4px 20px rgba(0, 243, 255, 0.3); text-transform: uppercase; letter-spacing: 1px; font-weight: bold;">
                FATTO
            </button>

            <!-- Log History for Current Exercise -->
            <div id="focusHistoryList"
                style="margin-top: 2rem; width: 100%; max-height: 100px; overflow-y: auto; font-size: 0.8rem; color: #666; text-align: left; border-top: 1px solid #222; padding-top: 1rem;">
                <!-- Previous sets show here -->
            </div>

        </div>

        <!-- Next Exercise Preview -->
        <div id="nextExercisePreview"
            style="display: none; margin-top: 1rem; width: 100%; padding: 0.75rem; background: rgba(0, 243, 255, 0.05); border: 1px solid rgba(0, 243, 255, 0.15); border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span
                    style="font-size: 0.7rem; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Prossimo</span>
                <span style="flex: 1; height: 1px; background: rgba(255,255,255,0.1);"></span>
            </div>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 0.5rem;">
                <span id="nextExerciseName"
                    style="font-size: 0.95rem; color: var(--color-primary); font-weight: 500;">‚Äî</span>
                <span id="nextExerciseSets" style="font-size: 0.75rem; color: var(--color-text-muted);">‚Äî serie</span>
            </div>
        </div>

        <!-- Bottom Progress -->
        <div style="margin-top: auto; width: 100%;">
            <div
                style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.8rem; color: #666;">
                <span>Progresso</span>
                <span id="focusProgressText">0%</span>
            </div>
            <div style="height: 6px; background: #222; border-radius: 3px; overflow: hidden;">
                <div id="focusProgressBar"
                    style="height: 100%; width: 0%; background: var(--color-primary); transition: width 0.3s ease;">
                </div>
            </div>
        </div>
    </div>

    <style>
        .btn-timer-adjust {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
        }

        .btn-timer-adjust:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>

    <script src="js/main.js"></script>
    <script src="js/pr-tracker.js"></script>

    <!-- Share Modal -->
    <div id="shareModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
        <div
            style="background: var(--color-surface); padding: 2rem; border-radius: 12px; width: 90%; max-width: 400px; text-align: center; border: 1px solid var(--color-border);">
            <h3 style="margin-bottom: 1.5rem;">Condividi Scheda</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                <button id="shareNative"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; border: none; color: white; padding: 1rem; background: linear-gradient(135deg, #00f3ff, #0099ff); border-radius: 8px; cursor: pointer; font-family: inherit;">
                    <span style="font-size: 2rem;">ÔøΩ</sppan>
                        <span>Condividi</span>
                </button>
                <a id="shareWhatsapp" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #25D366; border-radius: 8px;">
                    <span style="font-size: 2rem;">üíö</span>
                    <span>WhatsApp</span>
                </a>
                <a id="shareTelegram" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #0088cc; border-radius: 8px;">
                    <span style="font-size: 2rem;">‚úàÔ∏è</span>
                    <span>Telegram</span>
                </a>
                <a id="shareTwitter" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #1DA1F2; border-radius: 8px;">
                    <span style="font-size: 2rem;">ÔøΩ</sppan>
                        <span>X/Twitter</span>
                </a>
                <a id="shareFacebook" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #1877F2; border-radius: 8px;">
                    <span style="font-size: 2rem;">üìò</span>
                    <span>Facebook</span>
                </a>
                <a id="shareEmail" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #666; border-radius: 8px;">
                    <span style="font-size: 2rem;">üìß</span>
                    <span>Email</span>
                </a>
                <button id="shareCopy"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; border: none; color: white; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px; cursor: pointer; font-family: inherit; grid-column: span 3;">
                    <span style="font-size: 2rem;">üìã</span>
                    <span>Copia Link</span>
                </button>
            </div>

            <button id="closeShareModal" class="btn btn-outline" style="width: 100%;">Chiudi</button>
        </div>
    </div>

    <!-- RPE Info Modal -->
    <div id="rpeInfoModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10001; justify-content: center; align-items: center; padding: 1rem;">
        <div
            style="background: var(--color-surface); padding: 1.5rem; border-radius: 16px; width: 90%; max-width: 380px; border: 1px solid var(--color-primary); box-shadow: 0 8px 32px rgba(0, 243, 255, 0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h3 style="margin: 0; color: var(--color-primary); font-size: 1.1rem;">üí™ RPE - Rate of Perceived Exertion</h3>
                <button onclick="closeRpeInfoModal()" style="background: rgba(255,255,255,0.1); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 1rem;">&times;</button>
            </div>
            <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 1rem; line-height: 1.5;">
                La scala RPE misura lo <strong style="color: white;">sforzo percepito</strong> durante una serie, da 6 a 10:
            </p>
            <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 0.75rem; margin-bottom: 1rem;">
                <div style="display: flex; justify-content: space-between; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <span style="color: #4ade80; font-weight: 600;">RPE 6</span>
                    <span style="color: var(--color-text-muted); font-size: 0.8rem;">Molto facile, 4+ reps in riserva</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <span style="color: #86efac; font-weight: 600;">RPE 7</span>
                    <span style="color: var(--color-text-muted); font-size: 0.8rem;">Moderato, 3 reps in riserva</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <span style="color: #fbbf24; font-weight: 600;">RPE 8</span>
                    <span style="color: var(--color-text-muted); font-size: 0.8rem;">Impegnativo, 2 reps in riserva</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <span style="color: #fb923c; font-weight: 600;">RPE 9</span>
                    <span style="color: var(--color-text-muted); font-size: 0.8rem;">Molto duro, 1 rep in riserva</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 0.4rem 0;">
                    <span style="color: #f87171; font-weight: 600;">RPE 10</span>
                    <span style="color: var(--color-text-muted); font-size: 0.8rem;">Massimale, nessuna rep extra</span>
                </div>
            </div>
            <p style="color: var(--color-primary); font-size: 0.8rem; font-style: italic; margin: 0;">
                üí° Per la crescita muscolare, lavora tra RPE 7-9 sulla maggior parte delle serie.
            </p>
        </div>
    </div>

    <script>
        function openRpeInfoModal() {
            document.getElementById('rpeInfoModal').style.display = 'flex';
        }
        function closeRpeInfoModal() {
            document.getElementById('rpeInfoModal').style.display = 'none';
        }
        document.getElementById('rpeInfoModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'rpeInfoModal') closeRpeInfoModal();
        });
    </script>

    <!-- Module Script for Firebase Logic -->
    <script type="module">
        import { authService } from './js/auth-service.js';
        import { firestoreService } from './js/firestore-service.js';
        import { aiService } from './js/ai-service.js';
        import { EXERCISE_DB, MUSCLE_GROUPS, isBilateralDumbbell, calculateTotalWeight } from './js/exercise-db.js';
        import { notificationManager } from './js/notification-manager.js';
        import { mediaSessionManager } from './js/media-session-manager.js';

        document.addEventListener('DOMContentLoaded', () => {

            // Settings Dropdown Toggle
            const settingsHeader = document.getElementById('settingsHeader');
            const settingsContent = document.getElementById('settingsContent');
            const settingsToggle = document.getElementById('settingsToggle');

            if (settingsHeader && settingsContent && settingsToggle) {
                settingsHeader.addEventListener('click', () => {
                    const isHidden = settingsContent.style.display === 'none';
                    settingsContent.style.display = isHidden ? 'block' : 'none';
                    settingsToggle.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
                });
            }

            // Elements
            const authSection = document.getElementById('authSection');
            const profileContent = document.getElementById('profileContent');
            const authForm = document.getElementById('authForm');
            const authSwitchBtn = document.getElementById('authSwitchBtn');
            const nameGroup = document.getElementById('nameGroup');
            const authTitle = document.getElementById('authTitle');
            const authError = document.getElementById('authError');

            const profileAvatar = document.getElementById('profileAvatar');
            const avatarContainer = document.getElementById('avatarContainer');
            const photoInput = document.getElementById('photoInput');
            const profileNameDisplay = document.getElementById('profileNameDisplay');
            const profileEmailDisplay = document.getElementById('profileEmailDisplay');
            const profileNameInput = document.getElementById('profileNameInput');
            const logoutBtn = document.getElementById('logoutBtn');
            const syncBtn = document.getElementById('syncBtn');
            const syncStatus = document.getElementById('syncStatus');

            let isLoginMode = true;

            // --- Auth Logic ---

            // Switch between Login and Register
            authSwitchBtn.addEventListener('click', (e) => {
                e.preventDefault();
                isLoginMode = !isLoginMode;
                if (isLoginMode) {
                    authTitle.textContent = 'Accedi';
                    nameGroup.style.display = 'none';
                    authForm.querySelector('button[type="submit"]').textContent = 'Entra';
                    document.getElementById('authSwitchText').textContent = 'Non hai un account?';
                    authSwitchBtn.textContent = 'Registrati';
                } else {
                    authTitle.textContent = 'Registrati';
                    nameGroup.style.display = 'block';
                    authForm.querySelector('button[type="submit"]').textContent = 'Registrati';
                    document.getElementById('authSwitchText').textContent = 'Hai gi√† un account?';
                    authSwitchBtn.textContent = 'Accedi';
                }
            });

            // Handle Submit
            authForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                authError.textContent = '';
                const email = document.getElementById('emailInput').value;
                const password = document.getElementById('passwordInput').value;
                const name = document.getElementById('nameInput').value;

                let result;
                if (isLoginMode) {
                    result = await authService.login(email, password);
                } else {
                    result = await authService.register(email, password, name);
                }

                if (!result.success) {
                    let msg = result.message;
                    if (msg.includes('auth/invalid-email')) msg = 'Email non valida.';
                    if (msg.includes('auth/wrong-password')) msg = 'Password errata.';
                    if (msg.includes('auth/user-not-found')) msg = 'Utente non trovato.';
                    if (msg.includes('auth/email-already-in-use')) msg = 'Email gi√† in uso.';
                    authError.textContent = msg;
                }
                // Success is handled by auth state listener
            });

            // Logout
            logoutBtn.addEventListener('click', async () => {
                await authService.logout();
                window.location.reload(); // Clean state
            });


            // --- State Management ---

            authService.subscribe(async (user) => {
                if (user) {
                    // Logged In
                    authSection.classList.remove('visible');
                    profileContent.classList.add('visible');

                    profileEmailDisplay.textContent = user.email;
                    profileNameDisplay.innerHTML = user.displayName || 'Atleta <span class="text-primary">Pro</span>';
                    profileNameInput.value = user.displayName || '';

                    // Load Profile Data from LocalStorage (or trigger sync)
                    const localProfile = JSON.parse(localStorage.getItem('ironflow_profile') || '{}');
                    if (localProfile.photoUrl) {
                        profileAvatar.style.backgroundImage = `url('${localProfile.photoUrl}')`;
                        profileAvatar.textContent = '';
                    } else {
                        // Fallback to user photoURL from Auth if exists
                        if (user.photoURL) {
                            profileAvatar.style.backgroundImage = `url('${user.photoURL}')`;
                            profileAvatar.textContent = '';
                        }
                    }

                    // Load Workouts from Cloud
                    syncStatus.textContent = 'Sincronizzazione...';
                    const loadResult = await firestoreService.loadFromCloud();

                    if (loadResult.success) {
                        syncStatus.textContent = 'Cloud Sincronizzato';
                        setTimeout(() => syncStatus.textContent = '', 2000);
                        if (loadResult.data) {
                            renderWorkouts();

                            // Auto-restore Gemini API key from profile if local is empty
                            const cloudProfile = loadResult.data.profile || {};
                            if (cloudProfile.geminiKey && !aiService.hasKey()) {
                                console.log('üîë Auto-restoring Gemini API key from cloud profile...');
                                aiService.saveKey(cloudProfile.geminiKey);
                                const aiKeyInput = document.getElementById('aiKeyInput');
                                if (aiKeyInput) aiKeyInput.value = cloudProfile.geminiKey;
                            }

                            // Auto-check and refresh Google Fit token if needed
                            try {
                                if (typeof healthConnectService !== 'undefined') {
                                    const healthStatus = await healthConnectService.getStatus();
                                    if (healthStatus.hasToken && !healthStatus.tokenValid) {
                                        console.log('üîÑ Google Fit token expired, attempting auto-refresh...');
                                        await healthConnectService.refreshAccessToken();
                                        console.log('‚úÖ Google Fit token refreshed successfully');
                                    }
                                }
                            } catch (healthError) {
                                console.warn('Could not auto-refresh Google Fit token:', healthError.message);
                            }

                            // AI history is now automatically merged in loadFromCloud()
                            // Sync back to cloud to ensure both platforms have the merged history
                            const mergedAiHistory = JSON.parse(localStorage.getItem('ironflow_ai_plan_history') || '[]');
                            const cloudAiHistory = loadResult.data.aiPlanHistory || [];
                            if (mergedAiHistory.length !== cloudAiHistory.length) {
                                console.log('üìö AI history merged, syncing back to cloud...');
                                await firestoreService.syncToCloud();
                            }
                        }
                    }

                    // --- CHECK FOR SHARED WORKOUT IMPORT ---
                    const urlParams = new URLSearchParams(window.location.search);
                    const shareData = urlParams.get('shareData'); // Legacy base64 encoded
                    const shareId = urlParams.get('shareId'); // Legacy long ID
                    const shortId = urlParams.get('s'); // New short link format

                    if (shareData) {
                        if (confirm('√à stato rilevato un link di condivisione. Vuoi importare la scheda?')) {
                            try {
                                const json = decodeURIComponent(atob(shareData));
                                const newWorkout = JSON.parse(json);

                                // Validation
                                if (!newWorkout || !newWorkout.name || !Array.isArray(newWorkout.exercises)) {
                                    throw new Error("Dati scheda non validi");
                                }

                                // Assign new ID
                                newWorkout.id = generateWorkoutId();
                                newWorkout.name = `${newWorkout.name} (Importata)`;
                                newWorkout.fromShared = true;

                                const currentWorkouts = getStoredWorkouts();
                                currentWorkouts.unshift(newWorkout);
                                localStorage.setItem('ironflow_workouts', JSON.stringify(currentWorkouts));
                                renderWorkouts();

                                await firestoreService.syncToCloud();

                                window.history.replaceState({}, document.title, window.location.pathname);
                                alert(`Scheda "${newWorkout.name}" importata con successo!`);
                            } catch (e) {
                                console.error(e);
                                alert('Errore durante l\'importazione della scheda: link non valido.');
                            }
                        }
                    } else if (shortId || shareId) {
                        // Handle both new short format (?s=) and legacy format (?shareId=)
                        const linkId = shortId || shareId;
                        const isShortLink = !!shortId;

                        if (confirm('√à stato rilevato un link di condivisione. Vuoi importare la scheda?')) {
                            try {
                                console.log(`Importing shared workout: ${linkId} (short: ${isShortLink})`);
                                const workoutData = await firestoreService.getSharedWorkout(linkId);

                                if (!workoutData || !workoutData.name) {
                                    throw new Error('Dati scheda non validi');
                                }

                                const newWorkout = {
                                    ...workoutData,
                                    id: generateWorkoutId(),
                                    name: `${workoutData.name} (Importata)`,
                                    fromShared: true,
                                    importedFrom: linkId,
                                    importedAt: new Date().toISOString()
                                };

                                const currentWorkouts = getStoredWorkouts();
                                currentWorkouts.unshift(newWorkout);
                                localStorage.setItem('ironflow_workouts', JSON.stringify(currentWorkouts));
                                renderWorkouts();

                                await firestoreService.syncToCloud();

                                window.history.replaceState({}, document.title, window.location.pathname);
                                alert(`Scheda "${newWorkout.name}" importata con successo!`);
                            } catch (e) {
                                console.error('Error importing shared workout:', e);
                                alert('Errore importazione: ' + (e.message || 'Scheda non valida'));
                                window.history.replaceState({}, document.title, window.location.pathname);
                            }
                        } else {
                            // User declined - clean URL anyway
                            window.history.replaceState({}, document.title, window.location.pathname);
                        }
                    }

                } else {
                    // Not Logged In
                    authSection.classList.add('visible');
                    profileContent.classList.remove('visible');
                    // If share link present but not logged in, user will see auth form first
                    // Once logged in, this subscription runs again and handles the import

                    // Ferma l'auto-sync se l'utente si disconnette
                    if (window.autoSyncInterval) {
                        clearInterval(window.autoSyncInterval);
                        window.autoSyncInterval = null;
                        console.log('üõë Auto-sync fermato (utente disconnesso)');
                    }
                }
            });

            // --- AUTO-SYNC MANAGER ---
            // Sincronizza automaticamente all'avvio e ogni 5 minuti
            const AUTO_SYNC_INTERVAL = 5 * 60 * 1000; // 5 minuti in millisecondi

            const performAutoSync = async () => {
                try {
                    const user = authService.getCurrentUser();
                    if (!user) return;

                    console.log('üîÑ Auto-sync in corso...');
                    await firestoreService.syncToCloud();
                    console.log('‚úÖ Auto-sync completato:', new Date().toLocaleTimeString());
                } catch (error) {
                    console.warn('‚ö†Ô∏è Auto-sync fallito:', error.message);
                }
            };

            // Avvia auto-sync dopo il caricamento iniziale
            authService.subscribe(async (user) => {
                if (user) {
                    // Pulisce eventuali timer esistenti
                    if (window.autoSyncInterval) {
                        clearInterval(window.autoSyncInterval);
                    }

                    // Primo sync silenzioso dopo 3 secondi (dopo che tutto √® caricato)
                    setTimeout(() => {
                        performAutoSync();
                    }, 3000);

                    // Imposta il sync ogni 5 minuti
                    window.autoSyncInterval = setInterval(performAutoSync, AUTO_SYNC_INTERVAL);
                    console.log('üîÑ Auto-sync attivato: ogni 5 minuti');
                }
            });


            // --- Profile Features ---

            // Photo Upload
            avatarContainer.addEventListener('click', () => photoInput.click());

            photoInput.addEventListener('change', async (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];

                    // Optimistic UI update
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        profileAvatar.style.backgroundImage = `url('${e.target.result}')`;
                        profileAvatar.textContent = '';
                    }
                    reader.readAsDataURL(file);

                    syncStatus.textContent = 'Caricamento foto...';
                    const result = await firestoreService.uploadProfilePhoto(file);
                    if (result.success) {
                        syncStatus.textContent = 'Foto aggiornata!';
                    } else {
                        syncStatus.textContent = 'Errore caricamento foto';
                        alert('Errore: ' + result.message);
                    }
                }
            });

            // Name Update
            profileNameInput.addEventListener('change', async (e) => {
                const newName = e.target.value;
                profileNameDisplay.innerHTML = newName; // Immediate UI
                await firestoreService.updateProfileField('name', newName);
                await firestoreService.syncToCloud(); // Sync all
            });

            // Manual Sync
            syncBtn.addEventListener('click', async () => {
                syncStatus.textContent = 'Sync in corso...';
                await firestoreService.syncToCloud();
                syncStatus.textContent = 'Sincronizzato ora.';
                setTimeout(() => syncStatus.textContent = '', 2000);
            });

            // --- ImgBB Key Logic ---
            const imgbbKeyInput = document.getElementById('imgbbKeyInput');
            const saveImgbbKeyBtn = document.getElementById('saveImgbbKeyBtn');
            const imgbbKeyStatus = document.getElementById('imgbbKeyStatus');

            // Load Key
            const loadImgbbKey = async () => {
                const key = await firestoreService.getImgBBKey();
                if (key) {
                    imgbbKeyInput.value = key;
                    imgbbKeyStatus.textContent = 'Key salvata';
                }
            };
            // Call load only if elements exist (user might be logged out initially, but this runs on DOMContentLoaded)
            if (imgbbKeyInput) loadImgbbKey();

            // Save Key
            if (saveImgbbKeyBtn) {
                saveImgbbKeyBtn.addEventListener('click', async () => {
                    const key = imgbbKeyInput.value.trim();
                    if (!key) return;

                    saveImgbbKeyBtn.disabled = true;
                    saveImgbbKeyBtn.textContent = '...';

                    const result = await firestoreService.setImgBBKey(key);

                    saveImgbbKeyBtn.disabled = false;
                    saveImgbbKeyBtn.textContent = 'Salva';

                    if (result.success) {
                        imgbbKeyStatus.textContent = 'Key salvata con successo!';
                        imgbbKeyStatus.style.color = 'var(--color-primary)';
                        setTimeout(() => imgbbKeyStatus.textContent = '', 3000);
                    } else {
                        imgbbKeyStatus.textContent = 'Errore: ' + result.message;
                        imgbbKeyStatus.style.color = '#ff4444';
                    }
                });
            }

            // --- FOCUS MODE LOGIC ---
            const focusOverlay = document.getElementById('focusModeOverlay');
            const exitFocusModeBtn = document.getElementById('exitFocusMode');
            const focusActionBtn = document.getElementById('focusActionBtn');

            // New Elements
            const focusTimer = document.getElementById('focusTimer');
            const focusTimerArea = document.getElementById('focusTimerArea');
            const focusActiveArea = document.getElementById('focusActiveArea');
            const focusWeightInput = document.getElementById('focusWeightInput');
            const focusRepsInput = document.getElementById('focusRepsInput');
            const focusRpeInput = document.getElementById('focusRpeInput');
            const focusHistoryList = document.getElementById('focusHistoryList');
            const focusExerciseName = document.getElementById('focusExerciseName');
            const focusSetCounter = document.getElementById('focusSetCounter');
            const focusWorkoutTitle = document.getElementById('focusWorkoutTitle');
            const focusProgressBar = document.getElementById('focusProgressBar');
            const focusProgressText = document.getElementById('focusProgressText');
            const focusSuggestedWeight = document.getElementById('focusSuggestedWeight');
            const focusSuggestedValue = document.getElementById('focusSuggestedValue');
            const focusSuggestedBasis = document.getElementById('focusSuggestedBasis');
            const wellnessModal = document.getElementById('wellnessPromptModal');
            const wellnessForm = document.getElementById('wellnessForm');
            const cancelWellnessBtn = document.getElementById('cancelWellnessBtn');
            const sleepQualityInput = document.getElementById('sleepQualityInput');
            const energyLevelInput = document.getElementById('energyLevelInput');
            const stressLevelInput = document.getElementById('stressLevelInput');
            const sorenessLevelInput = document.getElementById('sorenessLevelInput');
            const sorenessMusclePicker = document.getElementById('sorenessMusclePicker');
            const sorenessMuscleHint = document.getElementById('sorenessMuscleHint');
            const clearSorenessSelectionBtn = document.getElementById('clearSorenessSelection');

            let currentWorkout = null;
            let currentExerciseIndex = 0;
            let currentSetIndex = 0;
            let isResting = false;
            let timerInterval = null;
            let remainingTime = 0;
            let currentWorkoutId = null;
            let sessionCompleted = false;
            let sessionStartTime = null;
            let sessionLogSaved = false;
            let pendingFocusWorkout = null;
            let currentWellnessSnapshot = null;

            // --- STEP BUTTONS INITIALIZATION ---
            // Initialize step buttons for wellness form
            document.querySelectorAll('.step-buttons-row').forEach(row => {
                const targetId = row.dataset.target;
                const hiddenInput = document.getElementById(targetId);
                
                row.querySelectorAll('.step-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Remove active from all siblings
                        row.querySelectorAll('.step-btn').forEach(b => b.classList.remove('active'));
                        // Set active on clicked
                        btn.classList.add('active');
                        // Update hidden input
                        if (hiddenInput) {
                            hiddenInput.value = btn.dataset.value;
                        }
                    });
                });
            });
            
            // Notes field auto-expand
            const notesField = document.getElementById('domsExternalCauseInput');
            if (notesField) {
                notesField.addEventListener('input', () => {
                    notesField.classList.toggle('has-content', notesField.value.trim().length > 0);
                });
            }

            // --- WEIGHT SUGGESTION SYSTEM ---
            // Cache delle stime 1RM calcolate dai log storici
            let exerciseEstimates = {};

            // Formula ibrida per calcolare 1RM (stessa usata in analysis.html)
            const calculateHybrid1RM = (weight, reps) => {
                if (reps === 1) return weight;
                if (reps > 15) return null;
                const epley = weight * (1 + reps / 30);
                const brzycki = weight * (36 / (37 - reps));
                const lombardi = weight * Math.pow(reps, 0.1);
                const mayhew = weight * (100 / (52.2 + 41.9 * Math.exp(-0.055 * reps)));
                const wathen = weight * (100 / (48.8 + 53.8 * Math.exp(-0.075 * reps)));
                return (epley * 0.25 + brzycki * 0.25 + lombardi * 0.15 + mayhew * 0.15 + wathen * 0.2);
            };

            // Percentuali NSCA per convertire 1RM in peso per X reps
            const rmPercentages = {
                1: 1.00, 2: 0.97, 3: 0.93, 4: 0.90, 5: 0.87,
                6: 0.85, 7: 0.83, 8: 0.80, 9: 0.77, 10: 0.75,
                11: 0.73, 12: 0.70, 13: 0.68, 14: 0.66, 15: 0.64
            };

            // Normalizza nome esercizio per matching (versione aggressiva)
            const normalizeExerciseName = (name) => {
                return (name || '').toLowerCase().trim()
                    .replace(/\s+/g, ' ')
                    .replace(/[√†√°√¢√£]/g, 'a')
                    .replace(/[√®√©√™√´]/g, 'e')
                    .replace(/[√¨√≠√Æ√Ø]/g, 'i')
                    .replace(/[√≤√≥√¥√µ]/g, 'o')
                    .replace(/[√π√∫√ª√º]/g, 'u')
                    .replace(/\(.*?\)/g, '') // Rimuove contenuto tra parentesi
                    .replace(/[:;,\-‚Äì]/g, ' ') // Rimuove punteggiatura
                    .replace(/\s+/g, ' ')
                    .trim();
            };

            // Trova i muscoli target di un esercizio
            const getExerciseMuscles = (exerciseName) => {
                const name = normalizeExerciseName(exerciseName);

                // Cerca match esatto in EXERCISE_DB
                for (const [exName, muscles] of Object.entries(EXERCISE_DB)) {
                    if (name === normalizeExerciseName(exName)) {
                        return { muscles, primaryMuscle: muscles[0], matchType: 'exact' };
                    }
                }

                // Cerca match parziale (contiene)
                for (const [exName, muscles] of Object.entries(EXERCISE_DB)) {
                    const normalizedDbName = normalizeExerciseName(exName);
                    if (name.includes(normalizedDbName) || normalizedDbName.includes(name)) {
                        return { muscles, primaryMuscle: muscles[0], matchType: 'partial' };
                    }
                }

                // Cerca per keyword comuni
                const keywords = {
                    'panca': 'chest', 'bench': 'chest', 'push': 'chest', 'chest': 'chest',
                    'traz': 'lats', 'pull': 'lats', 'lat': 'lats', 'row': 'lats', 'remator': 'lats',
                    'squat': 'quads', 'pressa': 'quads', 'leg': 'quads', 'affond': 'quads',
                    'stacco': 'hamstrings', 'deadlift': 'hamstrings',
                    'curl': 'biceps', 'bicip': 'biceps',
                    'tricip': 'triceps', 'french': 'triceps', 'pushdown': 'triceps',
                    'spall': 'front-delts', 'shoulder': 'front-delts', 'military': 'front-delts', 'lento': 'front-delts',
                    'lateral': 'side-delts', 'alzate': 'side-delts',
                    'crunch': 'abs', 'plank': 'abs', 'addominali': 'abs'
                };

                for (const [keyword, muscle] of Object.entries(keywords)) {
                    if (name.includes(keyword)) {
                        return { muscles: [muscle], primaryMuscle: muscle, matchType: 'keyword' };
                    }
                }

                return null;
            };

            // Trova esercizi simili con dati storici
            const findSimilarExerciseEstimate = (exerciseName) => {
                const muscleInfo = getExerciseMuscles(exerciseName);
                if (!muscleInfo) return null;

                const { primaryMuscle, muscles } = muscleInfo;
                let bestMatch = null;
                let bestScore = 0;

                // Cerca tra gli esercizi con dati storici
                for (const [estName, estimate] of Object.entries(exerciseEstimates)) {
                    const estMuscleInfo = getExerciseMuscles(estName);
                    if (!estMuscleInfo) continue;

                    // Calcola score di similarit√†
                    let score = 0;

                    // Match muscolo primario (peso alto)
                    if (estMuscleInfo.primaryMuscle === primaryMuscle) {
                        score += 10;
                    }

                    // Match muscoli secondari
                    const commonMuscles = muscles.filter(m => estMuscleInfo.muscles.includes(m));
                    score += commonMuscles.length * 2;

                    // Match stesso gruppo (push/pull/legs)
                    const getGroup = (muscle) => MUSCLE_GROUPS[muscle]?.group || 'other';
                    if (getGroup(primaryMuscle) === getGroup(estMuscleInfo.primaryMuscle)) {
                        score += 3;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {
                            name: estName,
                            estimate: estimate,
                            similarity: score,
                            primaryMuscle: estMuscleInfo.primaryMuscle
                        };
                    }
                }

                // Richiedi almeno un match sul muscolo primario
                return bestScore >= 10 ? bestMatch : null;
            };

            // Fattori di correzione per esercizi derivati
            const getExerciseCorrectionFactor = (newExercise, referenceExercise) => {
                const newName = normalizeExerciseName(newExercise);
                const refName = normalizeExerciseName(referenceExercise);

                // Esercizi con manubri tipicamente ~80% del bilanciere
                if ((newName.includes('manubr') || newName.includes('dumbbell')) &&
                    !refName.includes('manubr') && !refName.includes('dumbbell')) {
                    return 0.80;
                }

                // Varianti inclinate tipicamente ~85% della versione piana
                if (newName.includes('inclinat') && !refName.includes('inclinat')) {
                    return 0.85;
                }

                // Varianti unilaterali ~50% del bilaterale
                if ((newName.includes('singol') || newName.includes('single') || newName.includes('unilateral')) &&
                    !refName.includes('singol') && !refName.includes('single')) {
                    return 0.50;
                }

                // Default: stima conservativa al 85%
                return 0.85;
            };

            // Carica stime 1RM dai log storici
            const loadExerciseEstimates = () => {
                try {
                    const logs = JSON.parse(localStorage.getItem('ironflow_logs') || '[]');
                    exerciseEstimates = {};

                    logs.forEach(log => {
                        if (!log.exercises) return;
                        log.exercises.forEach(ex => {
                            const name = normalizeExerciseName(ex.name);
                            if (!name || !ex.sets) return;

                            ex.sets.forEach(set => {
                                const w = parseFloat(set.weight);
                                const r = parseInt(set.reps);
                                if (w > 0 && r > 0 && r <= 15) {
                                    const est1RM = calculateHybrid1RM(w, r);
                                    if (est1RM && (!exerciseEstimates[name] || est1RM > exerciseEstimates[name].est1RM)) {
                                        exerciseEstimates[name] = {
                                            est1RM: est1RM,
                                            basedOn: `${w}kg x ${r}`,
                                            date: log.date,
                                            originalName: ex.name
                                        };
                                    }
                                }
                            });
                        });
                    });

                    console.log('üìä Stime caricate:', Object.keys(exerciseEstimates).length, 'esercizi');
                } catch (e) {
                    console.warn('Errore caricamento stime:', e);
                    exerciseEstimates = {};
                }
            };

            // EXPOSE GLOBALLY for sync scripts
            window.loadExerciseEstimates = loadExerciseEstimates;

            // Calcola peso suggerito per esercizio e reps target
            const getSuggestedWeight = (exerciseName, targetReps) => {
                // FIX: Ricarica stime se vuote (utile post-sync su iOS)
                if (!exerciseEstimates || Object.keys(exerciseEstimates).length === 0) {
                    loadExerciseEstimates();
                }

                const name = normalizeExerciseName(exerciseName);

                // Parsa le reps target (gestisce range come "8-12")
                let reps = parseInt(targetReps);
                if (isNaN(reps)) {
                    const match = String(targetReps || '').match(/(\d+)/);
                    reps = match ? parseInt(match[1]) : null;
                }

                if (!reps || reps < 1 || reps > 15) reps = 10; // Default a 10 reps se non specificato

                const percentage = rmPercentages[reps] || 0.70;

                // STEP 1: Cerca match ESATTO (nome normalizzato identico)
                const exactMatch = exerciseEstimates[name];
                if (exactMatch && exactMatch.est1RM) {
                    let suggestedWeight = Math.round(exactMatch.est1RM * percentage * 2) / 2;

                    // FIX: Se esercizio bilaterale con manubri, dividi per 2 (assumendo che AI/DB forniscano totale)
                    if (isBilateralDumbbell(name)) {
                        suggestedWeight = suggestedWeight / 2;
                    }

                    return {
                        weight: suggestedWeight,
                        basedOn: exactMatch.basedOn, // es. "60kg x 8"
                        est1RM: Math.round(exactMatch.est1RM),
                        type: 'direct'
                    };
                }

                // STEP 2: Cerca match per parole chiave (pi√π robusto)
                const nameWords = name.split(' ').filter(w => w.length > 2);
                let bestMatch = null;
                let bestScore = 0;

                for (const [estName, estData] of Object.entries(exerciseEstimates)) {
                    const estWords = estName.split(' ').filter(w => w.length > 2);

                    // Calcola quante parole in comune
                    const commonWords = nameWords.filter(w => estWords.includes(w));
                    const score = commonWords.length;

                    // Match diretto se tutte le parole principali combaciano (almeno 2)
                    if (score >= Math.min(nameWords.length, estWords.length) && score >= 2) {
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = { estName, estData, isDirect: true };
                        }
                    }
                    // Match simile se almeno 1 parola chiave combacia
                    else if (score >= 1 && !bestMatch) {
                        bestMatch = { estName, estData, isDirect: false };
                    }
                }

                if (bestMatch && bestMatch.isDirect) {
                    let suggestedWeight = Math.round(bestMatch.estData.est1RM * percentage * 2) / 2;

                    // FIX: Se esercizio bilaterale con manubri, dividi per 2
                    if (isBilateralDumbbell(name)) {
                        suggestedWeight = suggestedWeight / 2;
                    }

                    return {
                        weight: suggestedWeight,
                        basedOn: bestMatch.estData.basedOn,
                        est1RM: Math.round(bestMatch.estData.est1RM),
                        type: 'direct'
                    };
                }

                // STEP 3: RIMOSSO su richiesta utente (evitare derivazioni indirette)
                // Il sistema deve basarsi solo sull'esercizio specifico o dati AI diretti.
                /*
                const similarMatch = findSimilarExerciseEstimate(exerciseName);
                if (similarMatch) {
                    // ...
                }
                */

                return null;
            };

            // Carica stime all'avvio
            loadExerciseEstimates();

            const DOMS_SELECTION_STORAGE_KEY = 'ironflow_last_doms_selection';
            const categoryOrder = ['push', 'pull', 'legs', 'core', 'other'];
            const groupLabels = {
                push: 'Spinta',
                pull: 'Trazione',
                legs: 'Lower Body',
                core: 'Core',
                other: 'Full Body'
            };

            const getCategoryRank = (key) => {
                const idx = categoryOrder.indexOf(key);
                return idx === -1 ? categoryOrder.length : idx;
            };

            const muscleOptions = Object.entries(MUSCLE_GROUPS).map(([id, meta]) => ({
                id,
                label: meta.label || id,
                category: meta.group || 'other'
            })).sort((a, b) => {
                const rankDiff = getCategoryRank(a.category) - getCategoryRank(b.category);
                if (rankDiff !== 0) return rankDiff;
                return a.label.localeCompare(b.label, 'it');
            });

            const muscleLabelMap = muscleOptions.reduce((acc, option) => {
                acc[option.id] = option.label;
                return acc;
            }, {});

            const loadStoredSelection = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(DOMS_SELECTION_STORAGE_KEY) || '[]');
                    return Array.isArray(raw) ? raw.filter(id => muscleLabelMap[id]) : [];
                } catch (error) {
                    console.warn('Impossibile leggere DOMS salvati:', error);
                    return [];
                }
            };

            let selectedSorenessMuscles = new Set(loadStoredSelection());

            const persistSorenessSelection = () => {
                localStorage.setItem(
                    DOMS_SELECTION_STORAGE_KEY,
                    JSON.stringify(Array.from(selectedSorenessMuscles))
                );
            };

            const updateSorenessHint = () => {
                if (!sorenessMuscleHint) return;
                if (!selectedSorenessMuscles.size) {
                    sorenessMuscleHint.textContent = 'Nessun distretto selezionato.';
                    return;
                }
                const labels = Array.from(selectedSorenessMuscles).map(id => muscleLabelMap[id] || id);
                sorenessMuscleHint.textContent = `Gruppi selezionati: ${labels.join(', ')}`;
            };

            const syncSorenessButtons = () => {
                if (!sorenessMusclePicker) return;
                sorenessMusclePicker.querySelectorAll('.doms-chip').forEach(btn => {
                    const id = btn.dataset.muscle;
                    const isActive = selectedSorenessMuscles.has(id);
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-pressed', String(isActive));
                });
            };

            const buildSorenessPicker = () => {
                if (!sorenessMusclePicker) return;
                sorenessMusclePicker.innerHTML = '';
                const grouped = muscleOptions.reduce((acc, option) => {
                    const key = option.category || 'other';
                    if (!acc[key]) acc[key] = [];
                    acc[key].push(option);
                    return acc;
                }, {});

                Object.keys(grouped)
                    .sort((a, b) => getCategoryRank(a) - getCategoryRank(b))
                    .forEach(category => {
                        // Category section with background
                        const section = document.createElement('div');
                        section.className = 'doms-category-section';
                        
                        const header = document.createElement('div');
                        header.className = 'doms-chip-group';
                        header.textContent = groupLabels[category] || category;
                        section.appendChild(header);

                        const wrapper = document.createElement('div');
                        wrapper.className = 'doms-chip-wrapper';

                        grouped[category].forEach(option => {
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.className = 'doms-chip' + (selectedSorenessMuscles.has(option.id) ? ' active' : '');
                            btn.dataset.muscle = option.id;
                            btn.textContent = option.label;
                            btn.setAttribute('role', 'option');
                            btn.setAttribute('aria-pressed', String(selectedSorenessMuscles.has(option.id)));
                            btn.addEventListener('click', () => {
                                if (selectedSorenessMuscles.has(option.id)) {
                                    selectedSorenessMuscles.delete(option.id);
                                } else {
                                    selectedSorenessMuscles.add(option.id);
                                }
                                btn.classList.toggle('active');
                                btn.setAttribute('aria-pressed', String(btn.classList.contains('active')));
                                persistSorenessSelection();
                                updateSorenessHint();
                            });
                            wrapper.appendChild(btn);
                        });

                        section.appendChild(wrapper);
                        sorenessMusclePicker.appendChild(section);
                    });
            };

            const hydrateSorenessSelection = () => {
                selectedSorenessMuscles = new Set(loadStoredSelection());
                syncSorenessButtons();
                updateSorenessHint();
            };

            buildSorenessPicker();
            updateSorenessHint();

            clearSorenessSelectionBtn?.addEventListener('click', (event) => {
                event.preventDefault();
                selectedSorenessMuscles.clear();
                persistSorenessSelection();
                syncSorenessButtons();
                updateSorenessHint();
            });

            // Share Modal Logic
            const shareModal = document.getElementById('shareModal');
            const closeShareModal = document.getElementById('closeShareModal');
            const shareWhatsapp = document.getElementById('shareWhatsapp');
            const shareTelegram = document.getElementById('shareTelegram');
            const shareTwitter = document.getElementById('shareTwitter');
            const shareFacebook = document.getElementById('shareFacebook');
            const shareEmail = document.getElementById('shareEmail');
            const shareCopy = document.getElementById('shareCopy');
            const shareNative = document.getElementById('shareNative');

            let currentShareUrl = '';
            let currentShareTitle = '';

            window.showShareModal = (title, url) => {
                const text = `Guarda la mia scheda "${title}" su GymBro!`;
                currentShareUrl = url;
                currentShareTitle = title;

                shareWhatsapp.href = `https://wa.me/?text=${encodeURIComponent(text + ' ' + url)}`;
                shareTelegram.href = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`;
                shareTwitter.href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
                shareFacebook.href = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
                shareEmail.href = `mailto:?subject=${encodeURIComponent('Scheda Allenamento GymBro')}&body=${encodeURIComponent(text + '\n\n' + url)}`;

                shareCopy.onclick = async () => {
                    await navigator.clipboard.writeText(url);
                    shareCopy.innerHTML = '<span style="font-size: 2rem;">‚úÖ</span><span>Copiato!</span>';
                    setTimeout(() => {
                        shareCopy.innerHTML = '<span style="font-size: 2rem;">üìã</span><span>Copia Link</span>';
                    }, 2000);
                };

                shareModal.style.display = 'flex';
            };

            // Native share button handler
            shareNative.addEventListener('click', async () => {
                if (navigator.share && currentShareUrl) {
                    try {
                        await navigator.share({
                            title: `Allenamento: ${currentShareTitle}`,
                            text: `Guarda la mia scheda "${currentShareTitle}" su GymBro!`,
                            url: currentShareUrl
                        });
                        shareModal.style.display = 'none';
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('Share failed:', err);
                        }
                    }
                } else {
                    // Fallback: copy to clipboard
                    await navigator.clipboard.writeText(currentShareUrl);
                    shareNative.innerHTML = '<span style="font-size: 2rem;">‚úÖ</span><span>Copiato!</span>';
                    setTimeout(() => {
                        shareNative.innerHTML = '<span style="font-size: 2rem;">üì§</span><span>Condividi</span>';
                    }, 2000);
                }
            });

            closeShareModal.addEventListener('click', () => {
                shareModal.style.display = 'none';
            });

            shareModal.addEventListener('click', (e) => {
                if (e.target === shareModal) shareModal.style.display = 'none';
            });

            // Global Helpers for HTML attributes
            window.adjustTimer = (seconds) => {
                if (timerWorker) {
                    timerWorker.postMessage({ action: 'adjust', seconds: seconds });
                } else {
                    // Fallback (visual update primarily, logic in interval)
                    // This is complex to sync without worker, but we try our best if worker fails
                    // Ideally worker is always present in modern browsers
                    alert("Funzione non disponibile senza supporto Web Worker.");
                }
            };

            window.skipRest = () => {
                stopTimer();
                isResting = false;
                nextSet();
            };

            const generateWorkoutId = () => {
                if (window.crypto?.randomUUID) {
                    return 'wf_' + crypto.randomUUID();
                }
                return 'wf_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
            };

            function getStoredWorkouts() {
                try {
                    const raw = JSON.parse(localStorage.getItem('ironflow_workouts') || '[]');
                    return Array.isArray(raw) ? raw : [];
                } catch (error) {
                    console.error('Errore lettura schede', error);
                    return [];
                }
            }

            const findWorkoutById = (id) => {
                if (!id) return null;
                return getStoredWorkouts().find(w => String(w.id) === String(id));
            };

            const parseTargetInfo = (value) => {
                if (value === undefined || value === null) return { label: '', numeric: '' };
                if (typeof value === 'number' && !Number.isNaN(value)) {
                    return { label: `${value}`, numeric: value };
                }
                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (!trimmed) return { label: '', numeric: '' };
                    const numeric = parseFloat(trimmed.replace(',', '.'));
                    return {
                        label: trimmed,
                        numeric: Number.isNaN(numeric) ? '' : numeric
                    };
                }
                return { label: '', numeric: '' };
            };

            const buildSetsFromPlan = (exercise) => {
                const rawCount = exercise.sets ?? exercise.series ?? exercise.setCount ?? exercise.seriesCount;
                const parsed = parseInt(rawCount, 10);
                const setCount = Number.isFinite(parsed) && parsed > 0 ? parsed : 1;
                const target = parseTargetInfo(exercise.reps);
                const baseWeight = Number(exercise.weight || exercise.defaultWeight || 0) || 0;

                return Array.from({ length: setCount }, () => ({
                    weight: baseWeight,
                    reps: target.numeric,
                    target: target.label
                }));
            };

            function cloneWorkout(workout) {
                if (!workout) return null;
                const clone = JSON.parse(JSON.stringify(workout));
                if (!Array.isArray(clone.exercises)) clone.exercises = [];
                clone.exercises = clone.exercises.map(ex => {
                    const safeSets = Array.isArray(ex.sets) && ex.sets.length
                        ? ex.sets.map(set => {
                            const targetInfo = parseTargetInfo(set.target || set.reps || ex.reps);
                            return {
                                weight: Number(set.weight ?? ex.weight ?? 0) || 0,
                                reps: set.reps !== undefined && set.reps !== null && set.reps !== '' ? set.reps : targetInfo.numeric,
                                target: set.target || targetInfo.label,
                                // PRESERVE per-set data
                                customRest: set.customRest !== undefined && set.customRest !== null && set.customRest !== '' ? parseInt(set.customRest) : null,
                                type: set.type || 'normal',
                                rpe: set.rpe !== undefined && set.rpe !== null ? set.rpe : null
                            };
                        })
                        : buildSetsFromPlan(ex);
                    return {
                        ...ex,
                        name: ex.name || 'Esercizio',
                        sets: safeSets
                    };
                });
                return clone;
            }

            function hydrateFocusWorkout(workout, { showNotice = false, skipClone = false } = {}) {
                const readyWorkout = skipClone ? workout : cloneWorkout(workout);
                if (!readyWorkout || !Array.isArray(readyWorkout.exercises) || readyWorkout.exercises.length === 0) {
                    return null;
                }
                currentWorkout = readyWorkout;
                currentExerciseIndex = 0;
                currentSetIndex = 0;
                sessionCompleted = false;
                isResting = false;
                focusHistoryList.innerHTML = '';
                if (showNotice) {
                    const notice = document.createElement('div');
                    notice.style.color = 'var(--color-primary)';
                    notice.style.fontSize = '0.8rem';
                    notice.textContent = 'Scheda aggiornata. Sessione riallineata.';
                    focusHistoryList.appendChild(notice);
                }
                focusWorkoutTitle.textContent = readyWorkout.name || 'Workout Personalizzato';
                updateFocusUI();
                return readyWorkout;
            }

            function syncFocusOverlayWithLatestPlan() {
                if (focusOverlay.style.display !== 'flex' || !currentWorkoutId) return;
                const updated = findWorkoutById(currentWorkoutId);
                if (!updated) {
                    finishWorkout(true);
                    return;
                }
                const refreshed = hydrateFocusWorkout(updated, { showNotice: true });
                if (!refreshed) {
                    finishWorkout(true);
                }
            }

            function openWellnessModal(workout) {
                pendingFocusWorkout = workout;
                currentWellnessSnapshot = null;
                wellnessModal.style.display = 'flex';
                sleepQualityInput.value = sleepQualityInput.value || 7;
                energyLevelInput.value = energyLevelInput.value || 7;
                stressLevelInput.value = stressLevelInput.value || 4;
                sorenessLevelInput.value = sorenessLevelInput.value || 3;
                hydrateSorenessSelection();
            }

            function closeWellnessModal() {
                wellnessModal.style.display = 'none';
                pendingFocusWorkout = null;
            }

            function startFocusSession(workout) {
                // Ricarica stime 1RM prima di iniziare (per avere dati aggiornati)
                loadExerciseEstimates();
                
                // üèÜ Reset sessione PR per nuovo allenamento Focus Mode
                if (typeof prTracker !== 'undefined') {
                    prTracker.resetSessionPRs();
                }

                const source = typeof workout === 'string'
                    ? findWorkoutById(workout)
                    : (workout?.id ? (findWorkoutById(workout.id) || workout) : workout);

                const hydrated = hydrateFocusWorkout(source || null);

                if (!hydrated) {
                    alert('Questa scheda non contiene esercizi validi. Aggiornala dal Creator prima di avviare la modalit√† Focus.');
                    return;
                }

                currentWorkoutId = hydrated.id || source?.id || null;
                sessionStartTime = Date.now();
                sessionLogSaved = false;

                // Expose variables globally for session recovery
                window.currentFocusWorkout = currentWorkout;
                window.focusModeStartTime = sessionStartTime;
                window.focusModeWellnessData = currentWellnessSnapshot;
                window.focusModeSessionCompleted = false;

                // Blocca scroll del body quando Focus Mode √® aperta
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                document.body.style.top = `-${window.scrollY}px`;

                focusOverlay.style.display = 'flex';
            }

            window.initFocusMode = (workout) => {
                notificationManager.requestPermission();
                // Start silent audio loop to keep audio active in background (critical for iOS)
                notificationManager.startSilentLoop();
                openWellnessModal(workout);
            };

            cancelWellnessBtn.addEventListener('click', () => {
                wellnessModal.style.display = 'none';
                pendingFocusWorkout = null;
            });

            wellnessForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const recordedAt = new Date().toISOString();
                const muscleSelection = Array.from(selectedSorenessMuscles);
                const externalCauseInput = document.getElementById('domsExternalCauseInput');
                const externalCause = externalCauseInput ? externalCauseInput.value.trim() : '';

                currentWellnessSnapshot = {
                    sleepQuality: parseInt(sleepQualityInput.value, 10),
                    energyLevel: parseInt(energyLevelInput.value, 10),
                    stressLevel: parseInt(stressLevelInput.value, 10),
                    sorenessLevel: parseInt(sorenessLevelInput.value, 10),
                    recordedAt,
                    sorenessMuscles: muscleSelection,
                    sorenessLabels: muscleSelection.map(id => muscleLabelMap[id] || id),
                    externalCause: externalCause || undefined // Only include if provided
                };

                // Clear external cause input for next session
                if (externalCauseInput) externalCauseInput.value = '';

                console.log('[Wellness] Snapshot created:', currentWellnessSnapshot);
                console.log('[Wellness] Selected DOMS muscles:', muscleSelection);
                if (externalCause) console.log('[Wellness] External cause:', externalCause);
                wellnessModal.style.display = 'none';
                if (pendingFocusWorkout) {
                    startFocusSession(pendingFocusWorkout);
                    pendingFocusWorkout = null;
                }
            });

            exitFocusModeBtn.addEventListener('click', () => {
                // Check if there's progress to save
                const hasProgress = currentExerciseIndex > 0 || currentSetIndex > 0;

                if (hasProgress) {
                    // Offer to save progress
                    const choice = confirm('Vuoi salvare i progressi per continuare dopo?\n\nOK = Salva e esci\nAnnulla = Esci senza salvare');

                    if (choice) {
                        // User wants to save - session will be saved by recovery manager
                        console.log('üíæ Saving session before exit...');
                        // Don't mark as completed so recovery manager keeps the session
                        window.focusModeSessionCompleted = false;
                    } else {
                        // User doesn't want to save - mark as completed to clear session
                        window.focusModeSessionCompleted = true;
                    }
                } else {
                    // No progress, just exit
                    window.focusModeSessionCompleted = true;
                }

                stopTimer();
                
                // üî¥ KILL SWITCH v2.0 - Terminazione su abort/exit (sequenziale)
                (async () => {
                    try {
                        await notificationManager.killAllTimersAndNotifications();
                        await mediaSessionManager.killSession();
                        // WEBAPP FIX: Forza pulizia MediaSession
                        setTimeout(() => {
                            if ('mediaSession' in navigator) {
                                navigator.mediaSession.metadata = null;
                                navigator.mediaSession.playbackState = 'none';
                            }
                        }, 100);
                    } catch (e) {
                        console.warn('Kill switch on exit error:', e);
                    }
                })();
                
                // Ripristina scroll del body
                const scrollY = document.body.style.top;
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.width = '';
                document.body.style.top = '';
                window.scrollTo(0, parseInt(scrollY || '0') * -1);
                focusOverlay.style.display = 'none';
            });

            let supersetModeActive = false;
            let unilateralModeActive = false;

            function renderUnilateralInputs(ex, set) {
                unilateralModeActive = true;

                // Get pre-filled values safely
                const weightLeft = set.weightLeft || set.weight || '';
                const weightRight = set.weightRight || set.weight || '';
                const repsLeft = set.repsLeft || set.reps || '';
                const repsRight = set.repsRight || set.reps || '';
                const rpeLeft = set.rpeLeft || set.rpe || '';
                const rpeRight = set.rpeRight || set.rpe || '';
                const targetReps = set.target || ex.reps || '';

                focusActiveArea.innerHTML = `
                <!-- Unilateral Mode Toggle (Active) -->
                <div id="focusUnilateralToggle" style="margin-bottom: 0.75rem;">
                    <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.6rem 1rem; background: linear-gradient(135deg, rgba(255,152,0,0.2), rgba(255,193,7,0.15)); border: 1px solid rgba(255,152,0,0.5); border-radius: var(--radius-md); transition: all 0.2s ease; box-shadow: 0 0 10px rgba(255,152,0,0.1);">
                        <div style="position: relative; width: 44px; height: 24px; background: rgba(255,152,0,0.2); border-radius: 12px; transition: background 0.2s;">
                            <input type="checkbox" id="unilateralToggleCheckbox" checked
                                style="opacity: 0; position: absolute; width: 100%; height: 100%; cursor: pointer; z-index: 2;">
                            <div id="unilateralToggleTrack" style="position: absolute; width: 100%; height: 100%; background: rgba(255,152,0,0.3); border-radius: 12px; transition: background 0.2s;"></div>
                            <div id="unilateralToggleThumb" style="position: absolute; top: 2px; left: 22px; width: 20px; height: 20px; background: #ffc107; border-radius: 50%; transition: transform 0.2s, background 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.1rem;">
                            <span style="color: #ff9800; font-size: 0.85rem; font-weight: 600; display: flex; align-items: center; gap: 0.4rem;">
                                üí™ Modalit√† Braccio Singolo
                            </span>
                            <span style="color: #ffcc80; font-size: 0.7rem;">
                                Attivo: Pesi separati DX/SX
                            </span>
                        </div>
                    </label>
                </div>

                <div class="unilateral-container" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,152,0,0.3); border-radius: 12px; padding: 1rem; position: relative; overflow: hidden;">
                    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 4px; background: linear-gradient(to right, #ff9800, #ffc107);"></div>
                    
                    <div style="text-align:center; margin-bottom:1rem; color:#ff9800; font-size:0.8rem; font-weight:bold; letter-spacing:1px; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span>üí™ BRACCIO SINGOLO</span>
                    </div>

                    <!-- Left Arm (Sinistro) -->
                    <div class="unilateral-block-left" style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px dashed rgba(255,255,255,0.1);">
                        <div style="font-size: 0.95rem; color: #ffc107; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>üëà Braccio Sinistro (SX)</span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px; border-left: 2px solid #ffc107;">
                                <label style="font-size: 0.6rem; color: #888;">KG SX</label>
                                <input type="number" id="focusWeightInput_Left" value="${weightLeft}" placeholder="Kg" style="width:100%; background:transparent; border:none; color:white; font-size:1.3rem; text-align:center; font-weight:bold;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">REPS SX</label>
                                <input type="number" id="focusRepsInput_Left" value="${repsLeft}" placeholder="${targetReps}" inputmode="numeric" min="1" step="1" style="width:100%; background:transparent; border:none; color:white; font-size:1.3rem; text-align:center; font-weight:bold;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">RPE</label>
                                <input type="number" id="focusRpeInput_Left" value="${rpeLeft}" placeholder="6-10" min="6" max="10" step="0.5" style="width:100%; background:transparent; border:none; color:white; font-size:1.3rem; text-align:center;">
                            </div>
                        </div>
                    </div>

                    <!-- Right Arm (Destro) -->
                    <div class="unilateral-block-right">
                        <div style="font-size: 0.95rem; color: #ff9800; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>üëâ Braccio Destro (DX)</span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px; border-left: 2px solid #ff9800;">
                                <label style="font-size: 0.6rem; color: #888;">KG DX</label>
                                <input type="number" id="focusWeightInput_Right" value="${weightRight}" placeholder="Kg" style="width:100%; background:transparent; border:none; color:white; font-size:1.3rem; text-align:center; font-weight:bold;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">REPS DX</label>
                                <input type="number" id="focusRepsInput_Right" value="${repsRight}" placeholder="${targetReps}" inputmode="numeric" min="1" step="1" style="width:100%; background:transparent; border:none; color:white; font-size:1.3rem; text-align:center; font-weight:bold;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">RPE</label>
                                <input type="number" id="focusRpeInput_Right" value="${rpeRight}" placeholder="6-10" min="6" max="10" step="0.5" style="width:100%; background:transparent; border:none; color:white; font-size:1.3rem; text-align:center;">
                            </div>
                        </div>
                    </div>
                </div>
                `;
            }

            function renderNormalInputs() {
                if (!supersetModeActive && !unilateralModeActive) return; // Already normal
                supersetModeActive = false;
                unilateralModeActive = false;

                focusActiveArea.innerHTML = `
                <div id="focusBilateralIndicator" style="display: none; background: linear-gradient(135deg, rgba(156,39,176,0.15), rgba(103,58,183,0.1)); border: 1px solid rgba(156,39,176,0.3); border-radius: var(--radius-md); padding: 0.5rem 1rem; margin-bottom: 0.75rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span style="font-size: 1rem;">üèãÔ∏è</span>
                        <span style="color: #ce93d8; font-size: 0.8rem; font-weight: 500;">Manubri Bilaterali</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;">‚Ä¢ Inserisci peso singolo manubrio</span>
                    </div>
                </div>
                <!-- Unilateral Mode Toggle (Single Arm) -->
                <div id="focusUnilateralToggle"
                    style="display: none; margin-bottom: 0.75rem;">
                    <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.6rem 1rem; background: linear-gradient(135deg, rgba(255,152,0,0.12), rgba(255,193,7,0.08)); border: 1px solid rgba(255,152,0,0.35); border-radius: var(--radius-md); transition: all 0.2s ease;">
                        <div style="position: relative; width: 44px; height: 24px; background: rgba(255,255,255,0.1); border-radius: 12px; transition: background 0.2s;">
                            <input type="checkbox" id="unilateralToggleCheckbox" 
                                style="opacity: 0; position: absolute; width: 100%; height: 100%; cursor: pointer; z-index: 2;">
                            <div id="unilateralToggleTrack" style="position: absolute; width: 100%; height: 100%; background: rgba(255,255,255,0.15); border-radius: 12px; transition: background 0.2s;"></div>
                            <div id="unilateralToggleThumb" style="position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.2s, background 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.1rem;">
                            <span style="color: #ff9800; font-size: 0.85rem; font-weight: 600; display: flex; align-items: center; gap: 0.4rem;">
                                üí™ Modalit√† Braccio Singolo
                            </span>
                            <span style="color: var(--color-text-muted); font-size: 0.7rem;">
                                Traccia pesi diversi per DX e SX
                            </span>
                        </div>
                    </label>
                </div>
                <div id="focusSuggestedWeight" style="display: none; background: linear-gradient(135deg, rgba(0,243,255,0.15), rgba(0,153,255,0.1)); border: 1px solid rgba(0,243,255,0.3); border-radius: var(--radius-md); padding: 0.6rem 1rem; margin-bottom: 1rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; flex-wrap: wrap;">
                        <span style="color: var(--color-text-muted); font-size: 0.75rem;">üí° Suggerito:</span>
                        <span id="focusSuggestedValue" style="color: var(--color-primary); font-weight: bold; font-size: 1.1rem;">--</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;" id="focusSuggestedBasis">(basato su storico)</span>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; margin-bottom: 1.5rem;">
                    <div style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label id="focusWeightLabel" style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">KG</label>
                        <input type="number" id="focusWeightInput" style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);" value="">
                    </div>
                    <div style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">REPS</label>
                        <input type="number" id="focusRepsInput" inputmode="numeric" min="1" step="1" style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);" value="">
                    </div>
                    <div style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">RPE</label>
                        <input type="number" id="focusRpeInput" min="6" max="10" step="0.5" style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);" value="" placeholder="6-10">
                    </div>
                </div>
                `;
            }

            function renderSupersetInputs(exA, exB, setA, setB) {
                supersetModeActive = true;
                unilateralModeActive = false; // Reset unilateral mode

                const targetA = setA?.target || exA.reps || '';
                const targetB = setB?.target || exB.reps || '';

                // Get suggestions for both
                const suggestA = getSuggestedWeight(exA.name, targetA);
                const suggestB = getSuggestedWeight(exB.name, targetB);

                // Senior Design: Clean grid layout, no box-in-box, large data numbers
                const htmlA = `
                    <div class="superset-block-a" style="
                        background: rgba(0, 243, 255, 0.04);
                        border-radius: 16px;
                        padding: 1rem 1rem 1.25rem;
                        margin-bottom: 0.75rem;
                    ">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                            <span style="
                                background: var(--color-primary);
                                color: #000;
                                font-weight: 800;
                                font-size: 0.7rem;
                                padding: 0.2rem 0.5rem;
                                border-radius: 4px;
                                letter-spacing: 0.5px;
                            ">A</span>
                            <span style="font-size: 0.95rem; font-weight: 600; color: #fff; flex: 1; line-height: 1.2;">${exA.name}</span>
                            ${suggestA ? `<span style="font-size: 0.7rem; color: rgba(0,243,255,0.7); white-space: nowrap;">üí° ${suggestA.weight}kg</span>` : ''}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 0.8fr; gap: 0.75rem;">
                            <div style="text-align: center;">
                                <label style="font-size: 0.6rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 0.25rem;">Kg</label>
                                <input type="number" id="focusWeightInput_A" value="${setA.weight || ''}" placeholder="${suggestA?.weight || '‚Äî'}" style="
                                    width: 100%;
                                    background: transparent;
                                    border: none;
                                    border-bottom: 2px solid rgba(0,243,255,0.3);
                                    color: white;
                                    font-size: 1.75rem;
                                    font-weight: 700;
                                    text-align: center;
                                    font-family: var(--font-display);
                                    padding: 0.25rem 0;
                                ">
                            </div>
                            <div style="text-align: center;">
                                <label style="font-size: 0.6rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 0.25rem;">Reps</label>
                                <input type="number" id="focusRepsInput_A" value="${setA.reps || ''}" placeholder="${targetA || '‚Äî'}" inputmode="numeric" min="1" step="1" style="
                                    width: 100%;
                                    background: transparent;
                                    border: none;
                                    border-bottom: 2px solid rgba(0,243,255,0.3);
                                    color: var(--color-primary);
                                    font-size: 2rem;
                                    font-weight: 800;
                                    text-align: center;
                                    font-family: var(--font-display);
                                    padding: 0.25rem 0;
                                ">
                            </div>
                            <div style="text-align: center;">
                                <label style="font-size: 0.6rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 0.25rem;">RPE</label>
                                <input type="number" id="focusRpeInput_A" value="${setA.rpe || ''}" placeholder="‚Äî" min="6" max="10" step="0.5" style="
                                    width: 100%;
                                    background: transparent;
                                    border: none;
                                    border-bottom: 2px solid rgba(255,255,255,0.15);
                                    color: rgba(255,255,255,0.7);
                                    font-size: 1.5rem;
                                    font-weight: 600;
                                    text-align: center;
                                    font-family: var(--font-display);
                                    padding: 0.25rem 0;
                                ">
                            </div>
                        </div>
                    </div>
                `;

                const htmlB = `
                    <div class="superset-block-b" style="
                        background: rgba(0, 0, 0, 0.3);
                        border-radius: 16px;
                        padding: 1rem 1rem 1.25rem;
                    ">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                            <span style="
                                background: #9c27b0;
                                color: #fff;
                                font-weight: 800;
                                font-size: 0.7rem;
                                padding: 0.2rem 0.5rem;
                                border-radius: 4px;
                                letter-spacing: 0.5px;
                            ">B</span>
                            <span style="font-size: 0.95rem; font-weight: 600; color: #fff; flex: 1; line-height: 1.2;">${exB.name}</span>
                            ${suggestB ? `<span style="font-size: 0.7rem; color: rgba(156,39,176,0.8); white-space: nowrap;">üí° ${suggestB.weight}kg</span>` : ''}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 0.8fr; gap: 0.75rem;">
                            <div style="text-align: center;">
                                <label style="font-size: 0.6rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 0.25rem;">Kg</label>
                                <input type="number" id="focusWeightInput_B" value="${setB.weight || ''}" placeholder="${suggestB?.weight || '‚Äî'}" style="
                                    width: 100%;
                                    background: transparent;
                                    border: none;
                                    border-bottom: 2px solid rgba(156,39,176,0.3);
                                    color: white;
                                    font-size: 1.75rem;
                                    font-weight: 700;
                                    text-align: center;
                                    font-family: var(--font-display);
                                    padding: 0.25rem 0;
                                ">
                            </div>
                            <div style="text-align: center;">
                                <label style="font-size: 0.6rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 0.25rem;">Reps</label>
                                <input type="number" id="focusRepsInput_B" value="${setB.reps || ''}" placeholder="${targetB || '‚Äî'}" inputmode="numeric" min="1" step="1" style="
                                    width: 100%;
                                    background: transparent;
                                    border: none;
                                    border-bottom: 2px solid rgba(156,39,176,0.3);
                                    color: #ce93d8;
                                    font-size: 2rem;
                                    font-weight: 800;
                                    text-align: center;
                                    font-family: var(--font-display);
                                    padding: 0.25rem 0;
                                ">
                            </div>
                            <div style="text-align: center;">
                                <label style="font-size: 0.6rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 0.25rem;">RPE</label>
                                <input type="number" id="focusRpeInput_B" value="${setB.rpe || ''}" placeholder="‚Äî" min="6" max="10" step="0.5" style="
                                    width: 100%;
                                    background: transparent;
                                    border: none;
                                    border-bottom: 2px solid rgba(255,255,255,0.15);
                                    color: rgba(255,255,255,0.7);
                                    font-size: 1.5rem;
                                    font-weight: 600;
                                    text-align: center;
                                    font-family: var(--font-display);
                                    padding: 0.25rem 0;
                                ">
                            </div>
                        </div>
                    </div>
                `;

                // Senior Design: Unified accent color (purple gradient), clean container
                focusActiveArea.innerHTML = `
                    <div class="superset-container" style="
                        background: linear-gradient(180deg, rgba(156,39,176,0.08) 0%, rgba(0,0,0,0.2) 100%);
                        border: 1px solid rgba(156,39,176,0.25);
                        border-radius: 20px;
                        padding: 1rem;
                        position: relative;
                    ">
                        <div style="
                            position: absolute;
                            top: -10px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
                            color: white;
                            font-size: 0.65rem;
                            font-weight: 700;
                            padding: 0.3rem 0.75rem;
                            border-radius: 20px;
                            letter-spacing: 1.5px;
                            text-transform: uppercase;
                            box-shadow: 0 2px 8px rgba(156,39,176,0.4);
                        ">üîó Superset</div>
                        ${htmlA}
                        ${htmlB}
                    </div>
                `;
            }

            focusActionBtn.addEventListener('click', () => {
                if (sessionCompleted) {
                    // Session completed normally - clear recovery data
                    window.focusModeSessionCompleted = true;
                    stopTimer();
                    // Ripristina scroll del body
                    const scrollY = document.body.style.top;
                    document.body.style.overflow = '';
                    document.body.style.position = '';
                    document.body.style.width = '';
                    document.body.style.top = '';
                    window.scrollTo(0, parseInt(scrollY || '0') * -1);
                    focusOverlay.style.display = 'none';
                    return;
                }

                if (isResting) {
                    window.skipRest();
                } else {
                    if (supersetModeActive) {
                        // === SUPERSET COMBINED LOGGING ===
                        const exA = currentWorkout.exercises[currentExerciseIndex];
                        const exB = currentWorkout.exercises[currentExerciseIndex + 1];
                        const setA = exA.sets[currentSetIndex];
                        const setB = exB.sets[currentSetIndex];

                        const wInputA = document.getElementById('focusWeightInput_A');
                        const rInputA = document.getElementById('focusRepsInput_A');
                        const rpeInputA = document.getElementById('focusRpeInput_A');
                        const wInputB = document.getElementById('focusWeightInput_B');
                        const rInputB = document.getElementById('focusRepsInput_B');
                        const rpeInputB = document.getElementById('focusRpeInput_B');

                        const valWA = parseFloat(wInputA?.value) || 0;
                        const valRA = rInputA?.value || setA?.target || setA?.reps || '';
                        const valRpeA = parseFloat(rpeInputA?.value) || 0;

                        const valWB = parseFloat(wInputB?.value) || 0;
                        const valRB = rInputB?.value || setB?.target || setB?.reps || '';
                        const valRpeB = parseFloat(rpeInputB?.value) || 0;

                        if (setA) {
                            setA.weight = valWA;
                            setA.reps = valRA;
                            if (valRpeA) setA.rpe = valRpeA;
                            // Check bilateral for A
                            setA.isBilateral = isBilateralDumbbell(exA.name);
                        }
                        if (setB) {
                            setB.weight = valWB;
                            setB.reps = valRB;
                            if (valRpeB) setB.rpe = valRpeB;
                            // Check bilateral for B
                            setB.isBilateral = isBilateralDumbbell(exB.name);
                        }

                        const historyItem = document.createElement('div');
                        historyItem.innerHTML = `
                            <div style="display:flex; flex-direction:column; gap:6px; border-left: 3px solid #9c27b0; padding-left: 10px; margin-bottom: 8px; background: linear-gradient(90deg, rgba(156,39,176,0.08), transparent); padding: 8px 8px 8px 10px; border-radius: 0 8px 8px 0;">
                                <div style="font-size:0.85rem; display:flex; align-items:center; gap:6px;">
                                    <span style="background:var(--color-primary); color:#000; font-size:0.6rem; font-weight:700; padding:2px 5px; border-radius:3px;">A</span>
                                    <span style="color:#fff; font-weight:600;">${valWA}kg</span>
                                    <span style="color:var(--color-primary); font-weight:700;">√ó ${valRA}</span>
                                </div>
                                <div style="font-size:0.85rem; display:flex; align-items:center; gap:6px;">
                                    <span style="background:#9c27b0; color:#fff; font-size:0.6rem; font-weight:700; padding:2px 5px; border-radius:3px;">B</span>
                                    <span style="color:#fff; font-weight:600;">${valWB}kg</span>
                                    <span style="color:#ce93d8; font-weight:700;">√ó ${valRB}</span>
                                </div>
                            </div>
                        `;
                        focusHistoryList.prepend(historyItem);
                        startRest();

                    } else if (unilateralModeActive) {
                        // === UNILATERAL LOGGING ===
                        const activeExercise = currentWorkout?.exercises?.[currentExerciseIndex];
                        const activeSet = activeExercise?.sets?.[currentSetIndex];

                        const wLeft = document.getElementById('focusWeightInput_Left').value;
                        const wRight = document.getElementById('focusWeightInput_Right').value;
                        const rLeft = document.getElementById('focusRepsInput_Left').value;
                        const rRight = document.getElementById('focusRepsInput_Right').value;
                        const rpeLeftVal = document.getElementById('focusRpeInput_Left').value;
                        const rpeRightVal = document.getElementById('focusRpeInput_Right').value;

                        const valWLeft = parseFloat(wLeft) || 0;
                        const valWRight = parseFloat(wRight) || 0;
                        const valRLeft = rLeft || activeSet?.target || activeSet?.reps || '';
                        const valRRight = rRight || activeSet?.target || activeSet?.reps || '';

                        if (activeSet) {
                            activeSet.isUnilateral = true;
                            // Reset bilateral just in case
                            activeSet.isBilateral = false;

                            activeSet.weightLeft = valWLeft;
                            activeSet.weightRight = valWRight;
                            activeSet.repsLeft = valRLeft;
                            activeSet.repsRight = valRRight;
                            activeSet.rpeLeft = rpeLeftVal ? parseFloat(rpeLeftVal) : 0;
                            activeSet.rpeRight = rpeRightVal ? parseFloat(rpeRightVal) : 0;

                            // Backward compatibility and summary fields
                            // Use average weight or max? Max is safer for PRs logic roughly, but separate is best.
                            // We save both, but 'weight' is used by charts usually. Let's use MAX to tracking strength cap.
                            activeSet.weight = Math.max(valWLeft, valWRight);
                            activeSet.reps = valRLeft; // Default to Left reps for summary
                            activeSet.rpe = Math.max(activeSet.rpeLeft, activeSet.rpeRight);
                        }

                        const historyItem = document.createElement('div');
                        // Format: 15kg SX / 16kg DX
                        const weightDisplay = `<span style="color:#ffc107">${valWLeft}kg SX</span> / <span style="color:#ff9800">${valWRight}kg DX</span>`;
                        const repsDisplay = `${valRLeft}`; // Simplified display if equal? No, let's keep simple.

                        const setTypeBadges = {
                            normal: '',
                            warmup: '<span style="color:#ffc107;font-size:0.8em;">[W]</span> ',
                            backoff: '<span style="color:#9c27b0;font-size:0.8em;">[B]</span> ',
                            dropset: '<span style="color:#f44336;font-size:0.8em;">[D]</span> ',
                            amrap: '<span style="color:#4caf50;font-size:0.8em;">[A]</span> ',
                            pause: '<span style="color:#ff9800;font-size:0.8em;">[P]</span> '
                        };
                        const setType = activeSet?.type || 'normal';
                        const typeBadge = setTypeBadges[setType] || '';

                        historyItem.innerHTML = `‚úÖ ${typeBadge}Set ${currentSetIndex + 1}: ${weightDisplay} x ${repsDisplay}`;
                        focusHistoryList.prepend(historyItem);
                        startRest();

                    } else {
                        // === NORMAL LOGGING ===
                        const weightInput = document.getElementById('focusWeightInput');
                        const repsInput = document.getElementById('focusRepsInput');
                        const rpeInput = document.getElementById('focusRpeInput');

                        const activeExercise = currentWorkout?.exercises?.[currentExerciseIndex];
                        const activeSet = activeExercise?.sets?.[currentSetIndex];

                        const weightInputRaw = weightInput.value.trim();
                        const repsInputRaw = repsInput.value.trim();
                        const rpeInputRaw = rpeInput.value.trim();

                        let loggedWeight = weightInputRaw === '' ? 0 : parseFloat(weightInputRaw) || 0;
                        const loggedReps = repsInputRaw || activeSet?.target || activeSet?.reps || '';
                        const loggedRpe = rpeInputRaw ? parseFloat(rpeInputRaw) : 0;

                        const isBilateral = isBilateralDumbbell(activeExercise?.name);
                        const totalWeight = isBilateral ? calculateTotalWeight(activeExercise?.name, loggedWeight) : loggedWeight;

                        if (activeSet) {
                            // FIX: Salviamo sempre il peso inserito (singolo manubrio se bilaterale) per mantenere input corretti
                            activeSet.weight = loggedWeight;
                            activeSet.isBilateral = isBilateral;
                            if (repsInputRaw) activeSet.reps = repsInputRaw;
                            if (loggedRpe > 0) activeSet.rpe = loggedRpe;
                        }

                        const historyItem = document.createElement('div');
                        const repsDisplay = loggedReps || '‚Äî';
                        const weightDisplay = totalWeight ? (isBilateral ? `${totalWeight}kg (${loggedWeight}x2)` : `${totalWeight}kg`) : '‚Äî';
                        const rpeDisplay = loggedRpe > 0 ? ` @ RPE ${loggedRpe}` : '';

                        const setTypeBadges = {
                            normal: '',
                            warmup: '<span style="color:#ffc107;font-size:0.8em;">[W]</span> ',
                            backoff: '<span style="color:#9c27b0;font-size:0.8em;">[B]</span> ',
                            dropset: '<span style="color:#f44336;font-size:0.8em;">[D]</span> ',
                            amrap: '<span style="color:#4caf50;font-size:0.8em;">[A]</span> ',
                            pause: '<span style="color:#ff9800;font-size:0.8em;">[P]</span> '
                        };
                        const setType = activeSet?.type || 'normal';
                        const typeBadge = setTypeBadges[setType] || '';

                        historyItem.innerHTML = `‚úÖ ${typeBadge}Set ${currentSetIndex + 1}: ${weightDisplay} x ${repsDisplay}${rpeDisplay}`;
                        focusHistoryList.prepend(historyItem);

                        startRest();
                    }
                }
            });

            function updateFocusUI() {
                if (!currentWorkout || !Array.isArray(currentWorkout.exercises) || currentWorkout.exercises.length === 0) {
                    finishWorkout(true);
                    return;
                }

                if (currentExerciseIndex >= currentWorkout.exercises.length) {
                    finishWorkout();
                    return;
                }

                const ex = currentWorkout.exercises[currentExerciseIndex];

                // Ensure sets exists
                if (!ex.sets || ex.sets.length === 0) {
                    // Skip exercise if empty
                    currentExerciseIndex++;
                    updateFocusUI();
                    return;
                }

                const set = ex.sets[currentSetIndex];

                // CHECK FOR SUPERSET COMBINED MODE
                // If this is Role A, and next is Role B of same Superset
                if (ex.supersetId && ex.supersetRole === 'A') {
                    const nextEx = currentWorkout.exercises[currentExerciseIndex + 1];
                    if (nextEx && nextEx.supersetId === ex.supersetId && nextEx.supersetRole === 'B') {
                        // Render Combined UI
                        const nextSet = nextEx.sets[currentSetIndex];
                        if (set && nextSet) {
                            focusExerciseName.textContent = `${ex.name} + ${nextEx.name}`;
                            focusExerciseName.style.fontSize = '1.1rem';

                            renderSupersetInputs(ex, nextEx, set, nextSet);
                            updateFocusCommon(ex, set);
                            return;
                        }
                    }
                }

                // Normal Mode
                focusExerciseName.textContent = ex.name;
                focusExerciseName.style.fontSize = '';

                renderNormalInputs();
                updateFocusCommon(ex, set);
            }

            function updateFocusCommon(ex, set) {
                const targetLabel = set?.target || ex.reps || '';
                const baseCounter = `Set ${currentSetIndex + 1} / ${ex.sets.length}`;

                // --- UNILATERAL MODE TOGGLE LOGIC ---
                const unilateralToggleWrapper = document.getElementById('focusUnilateralToggle');
                const unilateralCheckbox = document.getElementById('unilateralToggleCheckbox');

                if (unilateralToggleWrapper && unilateralCheckbox) {
                    unilateralToggleWrapper.style.display = 'block';

                    // Auto-switch based on saved data (only if not already in that mode)
                    if (set.isUnilateral && !unilateralModeActive) {
                        renderUnilateralInputs(ex, set);
                        updateFocusCommon(ex, set); // Re-bind and exit
                        return;
                    }

                    // Sync Checkbox State
                    unilateralCheckbox.checked = unilateralModeActive;

                    // Bind Change Event
                    unilateralCheckbox.onchange = (e) => {
                        if (e.target.checked) {
                            renderUnilateralInputs(ex, set);
                        } else {
                            renderNormalInputs();
                        }
                        updateFocusCommon(ex, set);
                    }
                }

                // Set Type Badge
                const setTypeLabels = {
                    normal: '',
                    warmup: 'üî• Warm-up',
                    backoff: 'üìâ Back-off',
                    dropset: '‚¨áÔ∏è Drop Set',
                    amrap: 'üí™ AMRAP',
                    pause: '‚è∏Ô∏è Pausa'
                };
                const setType = set?.type || 'normal';
                const setTypeLabel = setTypeLabels[setType] || '';

                let counterText = baseCounter;
                if (setTypeLabel) {
                    counterText = `${setTypeLabel} ‚Ä¢ ${baseCounter}`;
                }

                focusSetCounter.textContent = counterText;

                // Check if bilateral dumbbell exercise (Only relevant for Normal Mode indicator usually)
                const isBilateral = isBilateralDumbbell(ex.name);
                const bilateralIndicator = document.getElementById('focusBilateralIndicator');
                const weightLabel = document.getElementById('focusWeightLabel');

                if (bilateralIndicator) {
                    bilateralIndicator.style.display = isBilateral ? 'block' : 'none';
                }
                if (weightLabel) {
                    weightLabel.textContent = isBilateral ? 'KG (x1)' : 'KG';
                }

                // Populate Inputs for Normal Mode (Superset mode handles its own values in renderSupersetInputs)
                const weightInput = document.getElementById('focusWeightInput');
                const repsInput = document.getElementById('focusRepsInput');
                const rpeInput = document.getElementById('focusRpeInput');

                if (weightInput) {
                    weightInput.value = set.weight || '';
                    weightInput.placeholder = set.weight || 'Kg';
                }
                if (repsInput) {
                    repsInput.value = set.reps || '';
                    repsInput.placeholder = targetLabel || 'Reps';

                    // Update suggestion when reps change
                    repsInput.oninput = () => {
                        const val = repsInput.value;
                        if (val) {
                            const suggestion = getSuggestedWeight(ex.name, val);
                            const focusSuggestedWeight = document.getElementById('focusSuggestedWeight');
                            const focusSuggestedValue = document.getElementById('focusSuggestedValue');
                            const focusSuggestedBasis = document.getElementById('focusSuggestedBasis');

                            if (suggestion && focusSuggestedWeight) {
                                focusSuggestedValue.textContent = `${suggestion.weight} kg`;
                                if (suggestion.type === 'direct') {
                                    focusSuggestedBasis.textContent = `(1RM da ${suggestion.basedOn})`;
                                } else {
                                    focusSuggestedBasis.textContent = `(stimato da ${suggestion.basedOn})`;
                                }
                                focusSuggestedWeight.style.display = 'block';
                            }
                        }
                    };
                }
                if (rpeInput) {
                    rpeInput.value = set.rpe || '';
                }

                // Suggestions Logic
                const focusSuggestedWeight = document.getElementById('focusSuggestedWeight');
                const focusSuggestedValue = document.getElementById('focusSuggestedValue');
                const focusSuggestedBasis = document.getElementById('focusSuggestedBasis');

                if (focusSuggestedWeight && !supersetModeActive) {
                    const targetReps = set.target || ex.reps || '10';
                    let suggestion = null;

                    if (set.suggestedWeight) {
                        suggestion = {
                            weight: set.suggestedWeight,
                            basedOn: set.suggestedBasedOn || 'storico',
                            type: set.suggestedType || 'ai-generated'
                        };
                    } else {
                        // Calcola al volo dai dati storici
                        suggestion = getSuggestedWeight(ex.name, targetReps);
                    }

                    if (suggestion) {
                        focusSuggestedValue.textContent = `${suggestion.weight} kg`;

                        if (suggestion.type === 'direct') {
                            focusSuggestedBasis.textContent = `(1RM da ${suggestion.basedOn})`;
                            focusSuggestedWeight.style.background = 'linear-gradient(135deg, rgba(0,243,255,0.15), rgba(0,153,255,0.1))';
                            focusSuggestedWeight.style.borderColor = 'rgba(0,243,255,0.3)';
                        } else if (suggestion.type === 'similar' || suggestion.type === 'ai-generated') {
                            const basisText = suggestion.type === 'ai-generated' ? 'calcolato da AI' : `stimato da ${suggestion.basedOn}`;
                            focusSuggestedBasis.textContent = `(${basisText})`;
                            focusSuggestedWeight.style.background = 'linear-gradient(135deg, rgba(255,193,7,0.15), rgba(255,152,0,0.1))';
                            focusSuggestedWeight.style.borderColor = 'rgba(255,193,7,0.3)';
                        }

                        focusSuggestedWeight.style.display = 'block';
                    } else {
                        focusSuggestedWeight.style.display = 'none';
                    }
                }

                // Reset UI State
                focusActiveArea.style.display = 'block';
                focusTimerArea.style.display = 'none';
                focusActionBtn.textContent = "FATTO";
                focusActionBtn.className = 'btn btn-primary';
                focusActionBtn.style.background = 'var(--color-primary)';
                focusActionBtn.style.color = 'black';

                // Update Progress Bar
                const totalSets = currentWorkout.exercises.reduce((acc, e) => acc + (e.sets ? e.sets.length : 0), 0);
                // Calc completed
                let completed = 0;
                for (let i = 0; i < currentExerciseIndex; i++) completed += currentWorkout.exercises[i].sets.length;
                completed += currentSetIndex;

                const percent = Math.round((completed / totalSets) * 100);
                focusProgressBar.style.width = percent + '%';
                focusProgressText.textContent = percent + '%';

                // Update Next Exercise Preview
                const nextExercisePreview = document.getElementById('nextExercisePreview');
                const nextExerciseName = document.getElementById('nextExerciseName');
                const nextExerciseSets = document.getElementById('nextExerciseSets');

                if (nextExercisePreview && nextExerciseName && nextExerciseSets) {
                    let nextExIndex = currentExerciseIndex + 1;
                    if (supersetModeActive) nextExIndex++; // Skip the partner in preview

                    if (nextExIndex < currentWorkout.exercises.length) {
                        const nextEx = currentWorkout.exercises[nextExIndex];
                        nextExerciseName.textContent = nextEx.name || 'Esercizio';
                        const setsCount = nextEx.sets ? nextEx.sets.length : 0;
                        nextExerciseSets.textContent = `${setsCount} serie`;
                        nextExercisePreview.style.display = 'block';
                    } else {
                        // No more exercises after current
                        nextExercisePreview.style.display = 'none';
                    }
                }
            }

            let timerWorker = null;

            if (window.Worker) {
                timerWorker = new Worker('js/timer.worker.js');
                timerWorker.onmessage = function (e) {
                    if (e.data.action === 'tick') {
                        updateTimerDisplay(e.data.remaining);
                    } else if (e.data.action === 'complete') {
                        updateTimerDisplay(0);
                        notificationManager.triggerNotification();
                        window.skipRest();
                    }
                };
            }

            function startRest() {
                notificationManager.unlockAudio();
                isResting = true;

                // Hide inputs, show timer
                focusActiveArea.style.display = 'none';
                focusTimerArea.style.display = 'block';

                const currentEx = currentWorkout.exercises[currentExerciseIndex];
                const exName = currentEx.name.toLowerCase();

                // Check for superset logic
                let restTime = 90; // Default
                let restLabel = 'RECUPERO';

                if (currentEx.supersetId) {
                    if (supersetModeActive) {
                        // Combined Superset Mode (A+B just finished)
                        // Use inter-superset rest (usually defined on A)
                        restTime = currentEx.interRest || 90;
                        restLabel = 'RECUPERO SUPERSET';
                    } else {
                        // Sequential Mode
                        const nextExIndex = currentExerciseIndex + 1;
                        const nextEx = currentWorkout.exercises[nextExIndex];

                        if (currentEx.supersetRole === 'A' && nextEx?.supersetId === currentEx.supersetId) {
                            // Transitioning from A to B within superset
                            restTime = currentEx.intraRest || 0;
                            restLabel = 'TRANSIZIONE A‚ÜíB';

                            if (restTime === 0) {
                                // No rest, go directly to exercise B
                                isResting = false;
                                currentExerciseIndex++;
                                // Keep same set index for paired tracking
                                updateFocusUI();
                                return;
                            }
                        } else if (currentEx.supersetRole === 'B') {
                            // After completing B, check if we need inter-superset rest
                            const prevEx = currentWorkout.exercises[currentExerciseIndex - 1];
                            if (prevEx?.supersetId === currentEx.supersetId && prevEx?.supersetRole === 'A') {
                                // Use inter-superset rest from exercise A
                                restTime = prevEx.interRest || 90;
                                restLabel = 'RECUPERO SUPERSET';
                            }
                        }
                    }
                } else {
                    // Standard rest logic for non-superset exercises
                    const currentSet = currentEx.sets[currentSetIndex];
                    
                    // PRIORITY LOGIC:
                    // 1. If current set has customRest defined (any value, including 0), use it EXCLUSIVELY
                    // 2. Only if customRest is NOT defined (null/undefined), check exercise-level rest
                    // 3. Fallback to defaults based on exercise type
                    
                    const hasCustomRestDefined = currentSet && currentSet.customRest !== null && currentSet.customRest !== undefined && currentSet.customRest !== '';
                    
                    if (hasCustomRestDefined) {
                        // Serie has its own rest time - use it (even if 0 = no rest)
                        restTime = parseInt(currentSet.customRest) || 0;
                        console.log(`‚è±Ô∏è Using custom rest time for this set: ${restTime}s (series override)`);
                        
                        if (restTime === 0) {
                            // Custom rest = 0 means skip rest entirely for this set
                            console.log('‚è±Ô∏è Custom rest is 0 - skipping rest for this set');
                            isResting = false;
                            focusTimerArea.style.display = 'none';
                            nextSet();
                            return;
                        }
                    } else if (currentEx.rest && currentEx.rest > 0) {
                        // Use exercise-level rest only if no custom rest defined for series
                        restTime = currentEx.rest;
                        console.log(`‚è±Ô∏è Using exercise-level rest: ${restTime}s`);
                    } else if (exName.includes('squat') || exName.includes('stacco') || exName.includes('deadlift') || exName.includes('panca') || exName.includes('bench')) {
                        restTime = 180; // Compounds
                    } else if (exName.includes('curl') || exName.includes('alzate') || exName.includes('polpacci') || exName.includes('abs')) {
                        restTime = 60; // Isolation
                    }
                }

                // Update timer label
                const timerLabel = focusTimerArea.querySelector('div');
                if (timerLabel) timerLabel.textContent = restLabel;

                updateTimerDisplay(restTime);

                focusActionBtn.textContent = "SALTA REST";
                focusActionBtn.style.background = 'transparent';
                focusActionBtn.style.border = '1px solid #333';
                focusActionBtn.style.color = 'white';

                // Start Worker Timer
                if (timerWorker) {
                    timerWorker.postMessage({ action: 'start', duration: restTime });
                } else {
                    // Fallback if Workers not supported
                    const endTime = Date.now() + restTime * 1000;
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        const remaining = Math.ceil((endTime - Date.now()) / 1000);
                        if (remaining <= 0) {
                            clearInterval(timerInterval);
                            notificationManager.triggerNotification();
                            window.skipRest();
                        } else {
                            updateTimerDisplay(remaining);
                        }
                    }, 250);
                }
            }

            function updateTimerDisplay(seconds) {
                const m = Math.floor(seconds / 60).toString().padStart(2, '0');
                const s = (seconds % 60).toString().padStart(2, '0');
                focusTimer.textContent = `${m}:${s}`;
            }

            function stopTimer() {
                if (timerWorker) {
                    timerWorker.postMessage({ action: 'stop' });
                }
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = null;
            }

            function nextSet() {
                const ex = currentWorkout.exercises[currentExerciseIndex];
                const isSuperset = !!ex.supersetId;

                // Carry over values for the NEXT set/exercise if logic allows
                const carryData = (prev, next) => {
                    if (!prev || !next) return;
                    if ((!next.weight || next.weight === 0) && prev.weight) next.weight = prev.weight;
                    if ((next.reps === '' || next.reps === undefined || next.reps === null) && prev.reps) next.reps = prev.reps;
                    if (!next.target && prev.target) next.target = prev.target;
                };

                if (supersetModeActive) {
                    // COMBINED MODE: Both A and B done together
                    if (currentSetIndex < ex.sets.length - 1) {
                        const nextIndex = currentSetIndex + 1;
                        carryData(ex.sets[currentSetIndex], ex.sets[nextIndex]);

                        // Also carry for partner B
                        const exB = currentWorkout.exercises[currentExerciseIndex + 1];
                        if (exB && exB.supersetId === ex.supersetId) {
                            carryData(exB.sets[currentSetIndex], exB.sets[nextIndex]);
                        }

                        currentSetIndex++;
                    } else {
                        // Finished both
                        currentSetIndex = 0;
                        currentExerciseIndex += 2; // Jump past A and B
                    }
                } else if (isSuperset) {
                    // SEQUENTIAL MODE: A1 -> B1 -> A2 -> B2 ...
                    if (ex.supersetRole === 'A') {
                        // Finished set n of A, move to set n of B
                        // currentSetIndex remains same
                        currentExerciseIndex++;
                    } else if (ex.supersetRole === 'B') {
                        // Finished set n of B, check if we need to go back to A for n+1
                        const exA = currentWorkout.exercises[currentExerciseIndex - 1];
                        if (exA && exA.supersetId === ex.supersetId && currentSetIndex < exA.sets.length - 1) {
                            // Carry values from B(n) to B(n+1) for future
                            carryData(ex.sets[currentSetIndex], ex.sets[currentSetIndex + 1]);
                            // Also carry A(n) to A(n+1)
                            carryData(exA.sets[currentSetIndex], exA.sets[currentSetIndex + 1]);

                            currentSetIndex++;
                            currentExerciseIndex--; // Back to A
                        } else {
                            // Finished all rounds of A/B
                            currentSetIndex = 0;
                            currentExerciseIndex++;
                        }
                    } else {
                        // Superset without role? Fallback to normal
                        if (currentSetIndex < ex.sets.length - 1) {
                            carryData(ex.sets[currentSetIndex], ex.sets[currentSetIndex + 1]);
                            currentSetIndex++;
                        } else {
                            currentSetIndex = 0;
                            currentExerciseIndex++;
                        }
                    }
                } else {
                    // NORMAL MODE
                    if (currentSetIndex < ex.sets.length - 1) {
                        carryData(ex.sets[currentSetIndex], ex.sets[currentSetIndex + 1]);
                        currentSetIndex++;
                    } else {
                        currentSetIndex = 0;
                        currentExerciseIndex++;
                    }
                }

                // BOUNDS & PARTNER SKIP CHECK
                if (currentExerciseIndex >= currentWorkout.exercises.length) {
                    finishWorkout();
                    return;
                }

                focusHistoryList.innerHTML = ''; // Reset logging UI for new target

                // If we moved to B but B is already completed (unlikely in seq, common in combined if index drifted)
                const nextEx = currentWorkout.exercises[currentExerciseIndex];
                if (nextEx && nextEx.supersetRole === 'B' && nextEx.sets.every(s => s.weight > 0)) {
                    console.log('[Focus] Auto-skipping completed partner B:', nextEx.name);
                    currentExerciseIndex++;
                    if (currentExerciseIndex >= currentWorkout.exercises.length) {
                        finishWorkout();
                        return;
                    }
                }

                updateFocusUI();
            }

            function finishWorkout(empty = false) {
                sessionCompleted = true;

                // Mark session as completed for recovery manager
                window.focusModeSessionCompleted = true;

                // üî¥ KILL SWITCH v2.0 - Terminazione completa cross-platform
                // Esegui kill in sequenza per assicurare pulizia completa
                (async () => {
                    try {
                        // 1. Kill notification manager (audio context, oscillator)
                        await notificationManager.killAllTimersAndNotifications();
                        console.log('‚úÖ NotificationManager killed');
                        
                        // 2. Kill media session manager (audio element, MediaSession)
                        await mediaSessionManager.killSession();
                        console.log('‚úÖ MediaSessionManager killed');
                        
                        // 3. WEBAPP FIX: Forza pulizia MediaSession con piccolo delay
                        setTimeout(() => {
                            if ('mediaSession' in navigator) {
                                navigator.mediaSession.metadata = null;
                                navigator.mediaSession.playbackState = 'none';
                                console.log('‚úÖ MediaSession force-cleared after delay');
                            }
                        }, 100);
                        
                    } catch (e) {
                        console.warn('Kill switch error:', e);
                    }
                })();

                focusActiveArea.style.display = 'none';
                focusTimerArea.style.display = 'none';
                focusActionBtn.textContent = "CHIUDI";
                focusActionBtn.className = 'btn btn-primary';
                focusActionBtn.style.background = 'var(--color-primary)';
                focusActionBtn.style.border = 'none';
                focusActionBtn.style.color = 'black';
                focusHistoryList.innerHTML = '';

                if (empty) {
                    focusExerciseName.textContent = "Nessun esercizio disponibile";
                    focusSetCounter.textContent = "Aggiorna la scheda per iniziare.";
                    focusProgressBar.style.width = '0%';
                    focusProgressText.textContent = '0%';
                    sessionLogSaved = true;
                } else {
                    focusExerciseName.textContent = "Workout Completato!";
                    focusSetCounter.textContent = "Ottimo lavoro.";
                    focusProgressBar.style.width = '100%';
                    focusProgressText.textContent = '100%';
                    persistFocusLog();
                }
            }

            async function persistFocusLog() {
                if (sessionLogSaved) return;
                if (!currentWorkout || !Array.isArray(currentWorkout.exercises)) return;

                const exercises = currentWorkout.exercises.map(ex => {
                    const validSets = (ex.sets || []).map(set => {
                        // Check if unilateral
                        if (set.isUnilateral) {
                            const setData = {
                                weight: Math.max(Number(set.weightLeft || 0), Number(set.weightRight || 0)),
                                reps: Number(set.repsLeft || set.reps || 0),
                                isUnilateral: true,
                                weightLeft: Number(set.weightLeft || 0),
                                weightRight: Number(set.weightRight || 0),
                                repsLeft: Number(set.repsLeft || 0),
                                repsRight: Number(set.repsRight || 0)
                            };
                            if (set.rpeLeft || set.rpeRight) {
                                setData.rpe = Math.max(Number(set.rpeLeft || 0), Number(set.rpeRight || 0));
                                setData.rpeLeft = Number(set.rpeLeft || 0);
                                setData.rpeRight = Number(set.rpeRight || 0);
                            }
                            if (set.type && set.type !== 'normal') setData.type = set.type;
                            return setData;
                        }

                        const weightVal = Number(set.weight) || 0;
                        const repsVal = parseFloat(set.reps ?? set.target);
                        if (weightVal <= 0 || !Number.isFinite(repsVal) || repsVal <= 0) return null;

                        // Include RPE and set type if available
                        const setData = { weight: weightVal, reps: repsVal };
                        if (set.isBilateral) setData.isBilateral = true;

                        if (set.rpe !== undefined && set.rpe !== null && set.rpe !== '') {
                            setData.rpe = Number(set.rpe);
                        }
                        // Include set type if not normal
                        if (set.type && set.type !== 'normal') {
                            setData.type = set.type;
                        }
                        return setData;
                    }).filter(Boolean);

                    if (!validSets.length) return null;

                    // Calculate average RPE for the exercise
                    const setsWithRpe = validSets.filter(s => s.rpe !== undefined);
                    const avgRpe = setsWithRpe.length > 0
                        ? Math.round((setsWithRpe.reduce((sum, s) => sum + s.rpe, 0) / setsWithRpe.length) * 10) / 10
                        : undefined;

                    const exerciseData = { name: ex.name, sets: validSets };

                    // Include Superset Data
                    if (ex.supersetId) {
                        exerciseData.supersetId = ex.supersetId;
                        exerciseData.supersetRole = ex.supersetRole;
                        if (ex.intraRest !== undefined) exerciseData.intraRest = ex.intraRest;
                        if (ex.interRest !== undefined) exerciseData.interRest = ex.interRest;
                    }

                    if (avgRpe !== undefined) {
                        exerciseData.avgRpe = avgRpe;
                    }
                    return exerciseData;
                }).filter(Boolean);

                if (!exercises.length) {
                    sessionLogSaved = true;
                    return;
                }

                const totalVolume = exercises.reduce((acc, ex) => {
                    return acc + ex.sets.reduce((sum, set) => {
                        if (set.isUnilateral) {
                            return sum + (set.weightLeft * set.repsLeft) + (set.weightRight * set.repsRight);
                        }
                        const effectiveWeight = set.isBilateral ? set.weight * 2 : set.weight;
                        return sum + (effectiveWeight * set.reps);
                    }, 0);
                }, 0);

                const durationMinutes = sessionStartTime
                    ? Math.max(1, Math.round((Date.now() - sessionStartTime) / 60000))
                    : null;

                // Calculate average RPE for the entire workout
                const exercisesWithRpe = exercises.filter(ex => ex.avgRpe !== undefined);
                const workoutAvgRpe = exercisesWithRpe.length > 0
                    ? Math.round((exercisesWithRpe.reduce((sum, ex) => sum + ex.avgRpe, 0) / exercisesWithRpe.length) * 10) / 10
                    : undefined;

                const logs = JSON.parse(localStorage.getItem('ironflow_logs') || '[]');
                const logEntry = {
                    id: Date.now(),
                    workoutId: currentWorkoutId,
                    workoutName: currentWorkout?.name || 'Workout',
                    date: new Date().toISOString(),
                    duration: durationMinutes ? `${durationMinutes} min` : '',
                    totalVolume,
                    exercises,
                    avgRpe: workoutAvgRpe, // Average RPE for the entire workout
                    wellness: currentWellnessSnapshot ? { ...currentWellnessSnapshot } : undefined,
                    fromAI: !!currentWorkout?.fromAI,
                    source: 'focus'
                };
                console.log('[Focus] Saving log with wellness:', logEntry.wellness);
                console.log('[Focus] sorenessMuscles in log:', logEntry.wellness?.sorenessMuscles);
                if (!logEntry.wellness) delete logEntry.wellness;
                if (logEntry.avgRpe === undefined) delete logEntry.avgRpe;
                logs.unshift(logEntry);
                localStorage.setItem('ironflow_logs', JSON.stringify(logs));
                sessionLogSaved = true;
                currentWellnessSnapshot = null;

                // üèÜ RILEVAMENTO PR v2.0 - Focus Mode
                try {
                    if (typeof prTracker !== 'undefined') {
                        const newPRs = prTracker.detectPRsFromLog(logEntry);
                        if (newPRs.length > 0) {
                            console.log('üèÜ [Focus] Nuovi PR rilevati:', newPRs);
                        }
                        
                        // Notifica aggregata post-workout
                        const sessionPRs = prTracker.getSessionPRs();
                        if (sessionPRs.length > 0) {
                            console.log('üèÜ [Focus] Sessione completata con PRs:', sessionPRs);
                            await prTracker.notifyAggregatedPRs();
                        }
                    }
                } catch (prError) {
                    console.warn('[Focus] PR detection error:', prError);
                }

                try {
                    await firestoreService.syncToCloud();
                } catch (error) {
                    console.warn('Sync diario da Focus fallita:', error.message || error);
                }
            }

            const aiKeyInput = document.getElementById('aiKeyInput');
            const saveAiKeyBtn = document.getElementById('saveAiKeyBtn');
            const aiKeyStatus = document.getElementById('aiKeyStatus');

            // Load existing key
            if (aiService.hasKey()) {
                aiKeyInput.value = aiService.apiKey;
            }

            saveAiKeyBtn.addEventListener('click', async () => {
                const key = aiKeyInput.value;
                if (key) {
                    aiService.saveKey(key);

                    // Persist to Firestore (Profile)
                    aiKeyStatus.textContent = 'Salvataggio...';
                    const result = await firestoreService.updateProfileField('geminiKey', key);

                    if (result.success) {
                        aiKeyStatus.textContent = 'Key salvata e sincronizzata!';
                        aiKeyStatus.style.color = 'var(--color-primary)';
                    } else {
                        aiKeyStatus.textContent = 'Salvata localmente. Errore Cloud.';
                    }
                    setTimeout(() => aiKeyStatus.textContent = '', 2000);
                }
            });

            // Export Data (Existing logic adapted)
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const data = {
                        workouts: JSON.parse(localStorage.getItem('ironflow_workouts') || '[]'),
                        logs: JSON.parse(localStorage.getItem('ironflow_logs') || '[]'),
                        profile: JSON.parse(localStorage.getItem('ironflow_profile') || '{}'),
                        exportDate: new Date().toISOString()
                    };
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "gymbro_backup_" + new Date().toISOString().split('T')[0] + ".json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                });
            }


            window.addEventListener('storage', (event) => {
                if (event.key === 'ironflow_workouts') {
                    renderWorkouts();
                    syncFocusOverlayWithLatestPlan();
                }
            });

            window.addEventListener('focus', () => {
                renderWorkouts();
            });

            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) renderWorkouts();
            });

            // --- Existing Workout List Logic (Preserved) ---
            function renderWorkouts() {
                const list = document.getElementById('savedWorkoutsList');
                let workouts = getStoredWorkouts();
                if (!list) return;

                list.innerHTML = '';

                if (workouts.length === 0) {
                    list.innerHTML = '<p style="color: var(--color-text-muted);">Nessuna scheda salvata.</p>';
                } else {
                    let normalized = false;
                    workouts.forEach((w) => {
                        if (!w.id) {
                            w.id = generateWorkoutId();
                            normalized = true;
                        }
                        if (!Array.isArray(w.exercises)) {
                            w.exercises = [];
                        }
                        // Ensure createdAt timestamp exists
                        if (!w.createdAt) {
                            w.createdAt = w.lastModified || new Date().toISOString();
                            normalized = true;
                        }
                    });

                    if (normalized) {
                        localStorage.setItem('ironflow_workouts', JSON.stringify(workouts));
                    }

                    // Sort by creation date (newest first)
                    workouts.sort((a, b) => {
                        const dateA = new Date(a.createdAt || 0);
                        const dateB = new Date(b.createdAt || 0);
                        return dateB - dateA;
                    });

                    workouts.forEach((w, index) => {
                        const div = document.createElement('div');
                        div.className = 'workout-list-item';
                        const workoutIdAttr = w.id ? `data-id="${w.id}"` : '';
                        const workoutName = w.name || 'Workout senza nome';
                        const exercisesCount = Array.isArray(w.exercises) ? w.exercises.length : 0;
                        // Distingui AI classico da AI personalizzato
                        const isAI = w.fromAI || w.aiGenerated;
                        const isPersonalized = w.aiPersonalized;
                        let aiBadge = '';
                        if (isAI) {
                            if (isPersonalized) {
                                aiBadge = '<span class="ai-badge" style="background: linear-gradient(135deg, rgba(0,243,255,0.3), rgba(156,39,176,0.3)); border-color: #9c27b0;">AI+</span>';
                            } else {
                                aiBadge = '<span class="ai-badge">AI</span>';
                            }
                        }
                        
                        // Format creation date
                        let createdDateStr = '';
                        if (w.createdAt) {
                            const createdDate = new Date(w.createdAt);
                            createdDateStr = createdDate.toLocaleDateString('it-IT', { day: '2-digit', month: 'short', year: 'numeric' });
                        }
                        
                        div.innerHTML = `
                            <div class="workout-header">
                                <button class="btn-play start-workout" data-index="${index}" ${workoutIdAttr} title="Avvia Focus Mode">
                                    ‚ñ∂
                                </button>
                                <div class="workout-info">
                                    <div class="workout-title">
                                        ${workoutName}
                                        ${aiBadge}
                                    </div>
                                    <div class="workout-meta">
                                        <span>${exercisesCount} Esercizi</span>
                                        ${createdDateStr ? `<span class="workout-date">üìÖ ${createdDateStr}</span>` : ''}
                                    </div>
                                </div>
                                <div class="workout-action-icons">
                                    <a href="creator.html?id=${w.id}" class="btn-icon-action" title="Modifica">‚úèÔ∏è</a>
                                    <span class="btn-icon-action edit-rest-times" data-index="${index}" data-id="${w.id}" title="Modifica Recuperi">‚è±Ô∏è</span>
                                    <span class="btn-icon-action share-workout" data-id="${w.id}" title="Condividi Scheda">üîó</span>
                                    <span class="btn-icon-action delete delete-workout" data-id="${w.id}" title="Elimina">üóëÔ∏è</span>
                                </div>
                            </div>
                        `;
                        list.appendChild(div);
                    });

                    list.querySelectorAll('.start-workout').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const idx = Number(e.currentTarget.dataset.index);
                            const workoutId = e.currentTarget.dataset.id;
                            const stored = getStoredWorkouts();
                            let targetWorkout = workoutId ? stored.find(w => String(w.id) === String(workoutId)) : stored[idx];

                            if (!targetWorkout) {
                                alert('Scheda non trovata. Aggiorna la pagina per sincronizzare le modifiche.');
                                renderWorkouts();
                                return;
                            }

                            if (typeof window.initFocusMode === 'function') {
                                window.initFocusMode(targetWorkout);
                            } else {
                                alert('Focus Mode non ancora caricato. Riprova tra un secondo.');
                            }
                        });
                    });

                    // Share Workout Listener
                    list.querySelectorAll('.share-workout').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            const workoutId = e.target.dataset.id;
                            const stored = getStoredWorkouts();
                            const workout = stored.find(w => String(w.id) === String(workoutId));
                            if (!workout) {
                                alert('Scheda non trovata. Aggiorna la pagina.');
                                return;
                            }

                            e.target.textContent = '‚è≥';
                            try {
                                // URL-based sharing (No Database required)
                                const json = JSON.stringify(workout);
                                const encoded = btoa(encodeURIComponent(json));

                                const url = new URL(window.location.href);
                                url.searchParams.set('shareData', encoded);
                                url.searchParams.delete('shareId');

                                const shareUrl = url.toString();

                                if (shareUrl.length > 8000) {
                                    alert('Scheda troppo grande per la condivisione via link.');
                                    return;
                                }

                                // Native Share API (Mobile)
                                if (navigator.share) {
                                    await navigator.share({
                                        title: `Allenamento: ${workout.name}`,
                                        text: `Prova questa scheda di allenamento su GymBro: ${workout.name}`,
                                        url: shareUrl
                                    });
                                } else {
                                    // Desktop Fallback (Custom Modal)
                                    showShareModal(workout.name, shareUrl);
                                }

                            } catch (err) {
                                console.error(err);
                                if (err.name !== 'AbortError') {
                                    alert('Errore condivisione.');
                                }
                            } finally {
                                e.target.textContent = 'üîó';
                            }
                        });
                    });

                    list.querySelectorAll('.delete-workout').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            if (confirm('Sei sicuro?')) {
                                const workoutId = e.target.dataset.id;
                                if (!workoutId) return;
                                const workouts = getStoredWorkouts();
                                const idx = workouts.findIndex(w => String(w.id) === String(workoutId));
                                if (idx === -1) {
                                    alert('Scheda non trovata. Aggiorna la pagina.');
                                    return;
                                }
                                workouts.splice(idx, 1);
                                localStorage.setItem('ironflow_workouts', JSON.stringify(workouts));
                                renderWorkouts();
                                syncFocusOverlayWithLatestPlan();
                                // Auto sync deletion
                                if (authService.getCurrentUser()) {
                                    await firestoreService.syncToCloud();
                                }
                            }
                        });
                    });

                    // Edit Rest Times Listener
                    list.querySelectorAll('.edit-rest-times').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const workoutId = e.target.dataset.id;
                            const workouts = getStoredWorkouts();
                            const idx = workouts.findIndex(w => String(w.id) === String(workoutId));
                            const workout = workouts[idx];
                            if (!workout) {
                                alert('Scheda non trovata. Aggiorna la pagina.');
                                return;
                            }
                            openEditRestModal(workout, idx);
                        });
                    });
                }
            }

            // Initial render
            renderWorkouts();

            // Unit toggle (Existing)
            if (window.unitService) {
                const unitSelect = document.querySelectorAll('.setting-item select')[0];
                unitSelect.value = window.unitService.getSystem() === 'imperial' ? 'Imperiale (lbs/in)' : 'Metrico (kg/cm)';
                unitSelect.addEventListener('change', (e) => {
                    const val = e.target.value;
                    if (val.includes('Imperiale')) window.unitService.toggleSystem('imperial');
                    else window.unitService.toggleSystem('metric');
                });
            }

            // --- Edit Rest Times Modal Functions ---
            let currentEditingWorkoutIndex = null;

            function openEditRestModal(workout, index) {
                currentEditingWorkoutIndex = index;
                const modal = document.getElementById('editRestModal');
                const workoutNameEl = document.getElementById('editRestWorkoutName');
                const contentEl = document.getElementById('editRestContent');

                workoutNameEl.textContent = `üìã ${workout.name || 'Workout'}`;
                
                let html = '';
                if (workout.exercises && workout.exercises.length > 0) {
                    workout.exercises.forEach((ex, exIdx) => {
                        html += `<div style="background: rgba(255,255,255,0.03); border-radius: 12px; padding: 1rem; border: 1px solid rgba(255,255,255,0.08);">`;
                        html += `<div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--color-primary);">${ex.name || 'Esercizio ' + (exIdx + 1)}</div>`;
                        
                        if (ex.sets && ex.sets.length > 0) {
                            html += `<div style="display: flex; flex-direction: column; gap: 0.5rem;">`;
                            ex.sets.forEach((set, setIdx) => {
                                const customRest = set.customRest || '';
                                html += `
                                    <div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                        <span style="font-size: 0.85rem; color: var(--color-text-muted); min-width: 60px;">Serie ${setIdx + 1}</span>
                                        <input type="number" 
                                               class="rest-input input-compact" 
                                               data-exercise="${exIdx}" 
                                               data-set="${setIdx}"
                                               value="${customRest}"
                                               placeholder="sec"
                                               min="0" max="600"
                                               style="width: 80px; text-align: center;">
                                        <span style="font-size: 0.75rem; color: var(--color-text-muted);">sec</span>
                                    </div>
                                `;
                            });
                            html += `</div>`;
                        } else {
                            html += `<p style="color: var(--color-text-muted); font-size: 0.85rem;">Nessuna serie definita</p>`;
                        }
                        html += `</div>`;
                    });
                } else {
                    html = '<p style="color: var(--color-text-muted);">Nessun esercizio in questa scheda.</p>';
                }
                
                contentEl.innerHTML = html;
                modal.style.display = 'flex';
            }

            function closeEditRestModal() {
                document.getElementById('editRestModal').style.display = 'none';
                currentEditingWorkoutIndex = null;
            }

            async function saveRestTimes() {
                if (currentEditingWorkoutIndex === null) return;
                
                const workouts = getStoredWorkouts();
                const workout = workouts[currentEditingWorkoutIndex];
                if (!workout) return;

                // Gather all rest inputs
                const inputs = document.querySelectorAll('#editRestContent .rest-input');
                inputs.forEach(input => {
                    const exIdx = parseInt(input.dataset.exercise);
                    const setIdx = parseInt(input.dataset.set);
                    const value = input.value.trim();
                    
                    if (workout.exercises[exIdx] && workout.exercises[exIdx].sets[setIdx]) {
                        workout.exercises[exIdx].sets[setIdx].customRest = value ? parseInt(value) : null;
                    }
                });

                // Save to localStorage
                localStorage.setItem('ironflow_workouts', JSON.stringify(workouts));
                
                // Sync to cloud if logged in
                if (authService.getCurrentUser()) {
                    await firestoreService.syncToCloud();
                }

                closeEditRestModal();
                renderWorkouts();
                
                // Show feedback
                const toast = document.createElement('div');
                toast.style.cssText = 'position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: var(--color-primary); color: black; padding: 0.75rem 1.5rem; border-radius: 999px; font-weight: 600; z-index: 9999; animation: fadeIn 0.3s;';
                toast.textContent = '‚úì Recuperi salvati!';
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            }

            // Event listeners for Edit Rest Modal
            document.getElementById('closeEditRestModal')?.addEventListener('click', closeEditRestModal);
            document.getElementById('cancelEditRest')?.addEventListener('click', closeEditRestModal);
            document.getElementById('saveEditRest')?.addEventListener('click', saveRestTimes);
            document.getElementById('editRestModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'editRestModal') closeEditRestModal();
            });
        });
    </script>

    <!-- Health Auto Export Service (for Apple Health) -->
    <script src="js/health-auto-export-service.js"></script>

    <!-- Health Connect Integration Script (Google Fit + Apple Health via Health Auto Export) -->
    <script type="module">
        import { healthConnectService } from './js/health-connect-service.js';
        import { terraHealthService } from './js/terra-health-service.js';
        import { firestoreService } from './js/firestore-service.js';

        // UI Elements
        const providerSelection = document.getElementById('healthProviderSelection');
        const connectedActions = document.getElementById('healthConnectedActions');
        const connectGoogleFitBtn = document.getElementById('connectGoogleFitBtn');
        const connectAppleHealthBtn = document.getElementById('connectAppleHealthBtn');
        const syncBtn = document.getElementById('syncHealthBtn');
        const disconnectBtn = document.getElementById('disconnectHealthBtn');
        const statusText = document.getElementById('healthStatusText');
        const statusIcon = document.getElementById('healthStatusIcon');
        const toggleSwitch = document.getElementById('healthToggleSwitch');
        const lastSyncEl = document.getElementById('healthLastSync');
        const lastSyncTime = document.getElementById('lastSyncTime');

        // Current connected provider
        let currentProvider = null;

        // Toggle switch click handler
        toggleSwitch?.addEventListener('click', async () => {
            if (currentProvider) {
                // If connected, show disconnect confirmation
                if (confirm('Vuoi disconnetterti dalla connessione salute?')) {
                    disconnectBtn?.click();
                }
            } else {
                // If not connected, show provider selection
                providerSelection.style.display = providerSelection.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Update UI based on connection status
        async function updateHealthStatus() {
            try {
                // Check which provider is connected
                currentProvider = await firestoreService.getConnectedHealthProvider();
                console.log('Current health provider:', currentProvider);

                if (currentProvider) {
                    // Connected to a provider
                    const providerName = currentProvider === 'google_fit' ? 'Google Fit' :
                        currentProvider.includes('apple') ? 'Apple Health' :
                            currentProvider;

                    statusText.textContent = providerName;
                    statusText.style.color = '#10b981';
                    statusIcon.textContent = 'üü¢';
                    
                    // Update toggle state
                    toggleSwitch?.classList.add('active');
                    toggleSwitch?.setAttribute('aria-checked', 'true');

                    providerSelection.style.display = 'none';
                    connectedActions.style.display = 'block';

                    // Show last sync time
                    const lastSync = await firestoreService.getLastHealthSync();
                    if (lastSync && lastSync.syncTimestamp) {
                        lastSyncEl.style.display = 'block';
                        lastSyncTime.textContent = new Date(lastSync.syncTimestamp).toLocaleString('it-IT');
                    }
                } else {
                    // Not connected
                    statusText.textContent = 'Non connesso';
                    statusText.style.color = 'var(--color-text-muted)';
                    statusIcon.textContent = '‚ö™';
                    
                    // Update toggle state
                    toggleSwitch?.classList.remove('active');
                    toggleSwitch?.setAttribute('aria-checked', 'false');

                    providerSelection.style.display = 'none'; // Hidden by default, shown on toggle click
                    connectedActions.style.display = 'none';
                    lastSyncEl.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating health status:', error);
                statusText.textContent = '‚ùå Errore';
                statusText.style.color = '#ef4444';
                statusIcon.textContent = 'üî¥';
            }
        }

        // Connect Google Fit (Android)
        connectGoogleFitBtn.addEventListener('click', async () => {
            // Check for conflict with Terra
            const terraData = await firestoreService.getTerraUserData();
            if (terraData && terraData.userId) {
                alert('‚ö†Ô∏è Sei gi√† connesso ad Apple Health.\n\nPer usare Google Fit, devi prima disconnetterti da Apple Health.');
                return;
            }

            try {
                connectGoogleFitBtn.disabled = true;
                connectGoogleFitBtn.innerHTML = '‚è≥ Connessione...';

                await healthConnectService.connect();

                alert('‚úÖ Connesso a Google Fit!\nI tuoi dati verranno sincronizzati automaticamente.');
                await updateHealthStatus();
            } catch (error) {
                console.error('Errore connessione Google Fit:', error);
                alert('‚ùå Errore: ' + error.message);
            } finally {
                connectGoogleFitBtn.disabled = false;
                connectGoogleFitBtn.innerHTML = '<span style="font-size: 1.2rem;">ü§ñ</span> Google Fit <small style="font-size: 0.65rem; opacity: 0.7;">(Android)</small>';
            }
        });

        // Connect Apple Health (iOS via Health Auto Export app)
        connectAppleHealthBtn.addEventListener('click', async () => {
            // Check for conflict with Google Fit
            const googleFitConnected = await terraHealthService.isGoogleFitConnected();
            if (googleFitConnected) {
                alert('‚ö†Ô∏è Sei gi√† connesso a Google Fit.\n\nPer usare Apple Health, devi prima disconnetterti da Google Fit.');
                return;
            }

            try {
                // Show Health Auto Export setup modal
                await healthAutoExportService.showSetupModal();

                // After modal closes, check if configured
                setTimeout(async () => {
                    await updateHealthStatus();
                }, 1000);
            } catch (error) {
                console.error('Errore configurazione Apple Health:', error);
                alert('‚ùå Errore: ' + error.message);
            }
        });

        // Sync data
        syncBtn.addEventListener('click', async () => {
            try {
                syncBtn.disabled = true;
                syncBtn.innerHTML = '‚è≥ Sincronizzazione...';

                let result;
                if (currentProvider === 'google_fit') {
                    result = await healthConnectService.syncAllData();
                } else if (currentProvider === 'apple_health_auto_export') {
                    // Health Auto Export syncs automatically via webhook
                    // Just verify connection and show latest data
                    const isConnected = await healthAutoExportService.verifyConnection();
                    result = { success: isConnected };
                } else if (currentProvider && currentProvider.includes('terra')) {
                    await terraHealthService.loadUserConnection();
                    result = await terraHealthService.syncAllData();
                } else {
                    throw new Error('Nessun provider connesso');
                }

                if (result && result.success) {
                    alert('‚úÖ Dati sincronizzati con successo!');
                    await updateHealthStatus();
                } else {
                    alert('‚ùå Errore: ' + (result?.error || 'Errore sconosciuto'));
                }
            } catch (error) {
                console.error('Errore sync:', error);
                alert('‚ùå Errore: ' + error.message);
            } finally {
                syncBtn.disabled = false;
                syncBtn.innerHTML = '<span>üîÑ</span> Sincronizza Ora';
            }
        });

        // Disconnect
        disconnectBtn.addEventListener('click', async () => {
            const providerName = currentProvider === 'google_fit' ? 'Google Fit' : 'Apple Health';
            if (!confirm(`Sei sicuro di voler disconnettere ${providerName}?`)) return;

            try {
                disconnectBtn.disabled = true;
                disconnectBtn.innerHTML = '‚è≥...';

                if (currentProvider === 'google_fit') {
                    await healthConnectService.disconnect();
                } else if (currentProvider === 'apple_health_auto_export') {
                    await healthAutoExportService.disconnect();
                } else if (currentProvider && currentProvider.includes('terra')) {
                    await terraHealthService.loadUserConnection();
                    await terraHealthService.disconnect();
                }

                alert('‚úÖ Disconnesso con successo');
                await updateHealthStatus();
            } catch (error) {
                console.error('Errore disconnect:', error);
                alert('‚ùå Errore: ' + error.message);
            } finally {
                disconnectBtn.disabled = false;
                disconnectBtn.innerHTML = '<span>‚ùå</span> Disconnetti';
            }
        });

        // Listen for Terra connection events
        window.addEventListener('terraConnected', async (e) => {
            console.log('Terra connected event:', e.detail);
            await updateHealthStatus();
        });

        // Check URL for Terra callback
        async function checkTerraCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const terraStatus = urlParams.get('terra');

            if (terraStatus === 'success') {
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                // Refresh status
                await updateHealthStatus();
            } else if (terraStatus === 'error') {
                window.history.replaceState({}, document.title, window.location.pathname);
                alert('‚ùå Errore durante la connessione ad Apple Health. Riprova.');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await checkTerraCallback();
            await updateHealthStatus();
        });

        // Also update on page focus (in case user completed auth in another tab)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                updateHealthStatus();
            }
        });

        // Legacy: Keep old function name for compatibility
        document.addEventListener('DOMContentLoaded', () => {
            // Aspetta un momento per assicurarsi che l'autenticazione sia completa
            setTimeout(() => updateHealthStatus(), 500);
        });

        // Aggiorna status anche se gi√† caricato
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(() => updateHealthStatus(), 500);
        }

        // Ascolta i cambiamenti di autenticazione per aggiornare lo stato
        import('./js/auth-service.js').then(({ authService }) => {
            authService.subscribe((user) => {
                if (user) {
                    // Utente autenticato, aggiorna lo stato dopo un breve delay
                    setTimeout(() => updateHealthStatus(), 1000);
                }
            });
        });
    </script>

    <!-- Focus Mode UX: Mobile Keyboard Handler -->
    <script>
        (function () {
            const focusOverlay = document.getElementById('focusModeOverlay');
            const focusContent = document.getElementById('focusContentWrapper');

            // 1. Dynamic Padding on Resize (Visual Viewport)
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    if (!focusOverlay || focusOverlay.style.display === 'none') return;

                    // Detect keyboard opening (significant height reduction)
                    const ratio = window.visualViewport.height / window.innerHeight;
                    if (ratio < 0.85) {
                        // Keyboard likely open
                        // Add extra padding to allow scrolling inputs to center
                        focusContent.style.paddingBottom = '50vh'; // Large safe padding
                    } else {
                        // Keyboard closed
                        focusContent.style.paddingBottom = '20px'; // Default
                    }
                });
            }

            // 2. Scroll into View on Focus
            document.addEventListener('focusin', (e) => {
                if (!focusOverlay || focusOverlay.style.display === 'none') return;

                const target = e.target;
                if (target.tagName === 'INPUT' && focusOverlay.contains(target)) {
                    // Delay to wait for viewport resize
                    setTimeout(() => {
                        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 400);
                }
            });
        })();
    </script>
</body>

<!-- Focus Mode Enhancements Loader -->
<script type="module" src="./js/enhancements-loader.js"></script>

</html>